{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HCLIM Utilities","text":"<p>Welcome to the documentation for HCLIM Utilities, a collection of Python functions developed during the 2025 internship at Met \u00c9ireann.  </p> <p>These utilities provide convenient building blocks for analysing and visualising  climate model output, with a focus on the HCLIM regional climate model and related datasets.</p>"},{"location":"#overview","title":"Overview","text":"<p>This package contains tools for:</p> <ul> <li> <p>Data I/O   Functions to load GRIB and NetCDF files into <code>iris</code>    cubes and ensure consistent attributes and time handling.</p> </li> <li> <p>Gridding and regridding   Utilities to create target rectilinear grids, regrid cubes, and extract common    periods across multiple datasets.</p> </li> <li> <p>Diagnostics and statistics   Functions to compute rainfall accumulations, biases, diurnal cycles, and add    summary statistics (MAE, bias, standard deviation) directly to plots.</p> </li> <li> <p>Plotting   Ready-made plotting functions for:</p> </li> <li>Spatial parameter maps (temperature, pressure, precipitation, etc.)</li> <li>Bias plots and animations</li> <li>Cyclone tracks</li> <li> <p>Time series at specific locations or averaged over a region</p> </li> <li> <p>Animations   Functions for producing animated weather maps or parameter fields over time,    useful for case study analysis and communication.</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 (recommended via Conda)</li> <li>Iris </li> <li>Cartopy </li> <li>Xarray </li> <li>Matplotlib </li> <li>Tqdm </li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#master","title":"master","text":""},{"location":"api/#master.load_grib_files","title":"load_grib_files","text":"<pre><code>load_grib_files(folder, param, standard_name, constraint=None)\n</code></pre> <p>Load multiple GRIB files from a folder, extract a parameter, and merge into a single Iris cube.</p> <p>Each GRIB file is opened with Xarray (via cfgrib), converted to an Iris cube,  and combined into a merged cube with unified time units and equalised attributes.  Optionally, a constraint can be applied to extract a subset of the data.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>Path to the folder containing <code>.grib</code> or <code>.GRIB</code> files.</p> required <code>param</code> <code>str</code> <p>Variable/parameter name in the GRIB files to load (e.g., 't2m' for 2m temperature).</p> required <code>standard_name</code> <code>str</code> <p>Standard name to assign to the variable for consistency with CF conventions.</p> required <code>constraint</code> <code>Constraint</code> <p>Constraint to filter the merged cube (e.g., by time, level, or region).  Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>processed_cube</code> <code>Cube</code> <p>Merged Iris cube containing the requested parameter from all GRIB files.</p> Source code in <code>master.py</code> <pre><code>def load_grib_files(folder, param, standard_name, constraint=None):\n\t\"\"\"\n    Load multiple GRIB files from a folder, extract a parameter, and merge into a single Iris cube.\n\n    Each GRIB file is opened with Xarray (via cfgrib), converted to an Iris cube, \n    and combined into a merged cube with unified time units and equalised attributes. \n    Optionally, a constraint can be applied to extract a subset of the data.\n\n    Parameters\n    ----------\n    folder : str\n        Path to the folder containing `.grib` or `.GRIB` files.\n    param : str\n        Variable/parameter name in the GRIB files to load (e.g., 't2m' for 2m temperature).\n    standard_name : str\n        Standard name to assign to the variable for consistency with CF conventions.\n    constraint : iris.Constraint, optional\n        Constraint to filter the merged cube (e.g., by time, level, or region). \n        Default is None.\n\n    Returns\n    -------\n    processed_cube : iris.cube.Cube\n        Merged Iris cube containing the requested parameter from all GRIB files.\n    \"\"\"\n\t# Get list of files.\n\tfiles = [\n\t\tf for f in os.listdir(folder)\n\t\tif os.path.isfile(os.path.join(folder, f)) and (f.endswith(\".grib\") or f.endswith(\".GRIB\"))\n\t]\n\n\t# Loop through files.\n\tds_cubes = iris.cube.CubeList([])\n\tfor file in files:\n\t\t# Load file using Xarray via cfgrib.\n\t\tds_xarray = xr.open_dataset(\n\t\t\t\"{}/{}\".format(folder, file), engine=\"cfgrib\", decode_timedelta=True\n\t\t)[param]\n\t\tds_xarray.attrs[\"standard_name\"] = standard_name\n\n\t\t# Convert to Iris cube.\n\t\tds_cube = ds_xarray.to_iris()\n\n\t\t# Append to cube list.\n\t\tds_cubes.append(ds_cube)\n\n\t# Unify time units.\n\tunify_time_units(ds_cubes)\n\t# Equalise attributes.\n\tequalise_attributes(ds_cubes)\n\t# Concatenate.\n\tprocessed_cube = ds_cubes.merge_cube()\n\n\t# Add constraint if relevant.\n\tif constraint != None:\n\t\t# Extract.\n\t\tprocessed_cube = processed_cube.extract(constraint)\n\n\treturn processed_cube\n</code></pre>"},{"location":"api/#master.load_hclim_netcdf","title":"load_hclim_netcdf","text":"<pre><code>load_hclim_netcdf(files, param, constraint=None)\n</code></pre> <p>Load a list of HCLIM NetCDF files, extract monthly subsets, and merge into a single cube.</p> <p>Each input file is assumed to contain data for (at most) one full month. The function  then constrains each cube to exactly one month using the first timestamp in the file, then  concatenates all processed cubes into a single Iris cube. Optionally, a further constraint  can be applied to the final cube.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list of str or str</code> <p>Paths to the NetCDF files to load. Can be a single file path or a list of paths.</p> required <code>param</code> <code>str or Constraint</code> <p>Variable/parameter to load from each file.</p> required <code>constraint</code> <code>Constraint</code> <p>Constraint to apply to the final merged cube (e.g., for a subset by time, level, or region).  Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>processed_cube</code> <code>Cube</code> <p>Concatenated Iris cube containing the monthly subsets from all NetCDF files.</p> Source code in <code>master.py</code> <pre><code>def load_hclim_netcdf(files, param, constraint=None):\n\t\"\"\"\n    Load a list of HCLIM NetCDF files, extract monthly subsets, and merge into a single cube.\n\n    Each input file is assumed to contain data for (at most) one full month. The function \n    then constrains each cube to exactly one month using the first timestamp in the file, then \n    concatenates all processed cubes into a single Iris cube. Optionally, a further constraint \n    can be applied to the final cube.\n\n    Parameters\n    ----------\n    files : list of str or str\n        Paths to the NetCDF files to load. Can be a single file path or a list of paths.\n    param : str or iris.Constraint\n        Variable/parameter to load from each file.\n    constraint : iris.Constraint, optional\n        Constraint to apply to the final merged cube (e.g., for a subset by time, level, or region). \n        Default is None.\n\n    Returns\n    -------\n    processed_cube : iris.cube.Cube\n        Concatenated Iris cube containing the monthly subsets from all NetCDF files.\n    \"\"\"\n\t# Load list of NetCDF files.\n\traw_cubes = iris.load(files, param)\n\n\t# Loop through list of files.\n\tprocessed_cubes = iris.cube.CubeList([])\n\tfor it in range(len(raw_cubes)):\n\t\t# Get cube.\n\t\traw_cube = raw_cubes[it]\n\n\t\t# Make sure each file only contains one month.\n\t\t# Get time coordinate.\n\t\tcube_it_time = raw_cubes[it].coord(\"time\")\n\t\t# Get relevant date of the first day of the month.\n\t\tfirst_date = cube_it_time.units.num2date(\n\t\t\tcube_it_time.points\n\t\t)[0]\n\t\tfirst_date = datetime(\n\t\t\tfirst_date.year, first_date.month, first_date.day,\n\t\t\tfirst_date.hour, first_date.minute, first_date.second\n\t\t)\n\t\t# First day of next month.\n\t\tlast_date = first_date + relativedelta(months=+1)\n\t\t# Create constraint.\n\t\tmonth_constraint = iris.Constraint(\n\t\t\ttime=lambda cell: first_date &lt;= cell.point &lt; last_date\n\t\t)\n\t\t# Extract based on constraint.\n\t\tcube = raw_cube.extract(month_constraint)\n\n\t\t# Append to list.\n\t\tprocessed_cubes.append(cube)\n\n\t# Concatenate into a single cube.\n\t# Unify time units.\n\tunify_time_units(processed_cubes)\n\t# Equalise attributes.\n\tequalise_attributes(processed_cubes)\n\t# Concatenate.\n\tprocessed_cube = processed_cubes.concatenate_cube()\n\n\t# Add constraint if relevant.\n\tif constraint != None:\n\t\t# Extract.\n\t\tprocessed_cube = processed_cube.extract(constraint)\n\n\treturn processed_cube\n</code></pre>"},{"location":"api/#master.calculate_rainfall_accumulation","title":"calculate_rainfall_accumulation","text":"<pre><code>calculate_rainfall_accumulation(pr_cube_input)\n</code></pre> <p>Compute daily (09Z\u201309Z) rainfall accumulations from a time-series precipitation cube.</p> <p>The function creates a categorised time coordinate that bins timesteps into daily windows defined from 09:00 UTC on day N to 08:59:59 UTC on day N+1 (labelled internally at 21:00 UTC). It then sums precipitation over each bin, converts the result to millimetres, and returns a cube of daily totals. The first and last (potentially partial) bins are dropped.</p> <p>Parameters:</p> Name Type Description Default <code>pr_cube_input</code> <code>Cube</code> <p>Time-series precipitation cube with a <code>time</code> coordinate. Expected units are a rate convertible to <code>kg m-2 s-1</code> (e.g., mm/s), sampled at regular 3-hourly intervals. The 3-hourly cadence is assumed for the conversion using <code>10800 s</code> per step.</p> required <p>Returns:</p> Name Type Description <code>rainfall_cube</code> <code>Cube</code> <p>Daily precipitation totals aggregated over 09Z\u201309Z windows. The cube has:   - <code>standard_name</code> set to <code>'precipitation_amount'</code>   - <code>long_name</code> set to <code>'Daily Total Precipitation Amount'</code>   - <code>units</code> set to <code>'mm'</code> The auxiliary categorisation coordinate is removed before returning.</p> Notes <ul> <li>Conversion to millimetres assumes 3-hourly time steps and rate units of   <code>kg m-2 s-1</code>: for each step, amount = rate \u00d7 10800 s, and   <code>1 kg m-2 == 1 mm</code> water equivalent.</li> <li>The first and last bins are sliced off (<code>[1:-1]</code>) to avoid partial days.</li> <li>The internal day labels are placed at 21:00 UTC corresponding to the   end of each 09Z\u201309Z window.</li> </ul> Source code in <code>master.py</code> <pre><code>def calculate_rainfall_accumulation(pr_cube_input):\n\t\"\"\"\n    Compute daily (09Z\u201309Z) rainfall accumulations from a time-series precipitation cube.\n\n    The function creates a categorised time coordinate that bins timesteps into\n    daily windows defined from 09:00 UTC on day *N* to 08:59:59 UTC on day *N+1*\n    (labelled internally at 21:00 UTC). It then sums precipitation over each bin,\n    converts the result to millimetres, and returns a cube of daily totals.\n    The first and last (potentially partial) bins are dropped.\n\n    Parameters\n    ----------\n    pr_cube_input : iris.cube.Cube\n        Time-series precipitation cube with a ``time`` coordinate.\n        Expected units are a rate convertible to ``kg m-2 s-1`` (e.g., mm/s),\n        sampled at regular **3-hourly** intervals. The 3-hourly cadence is\n        assumed for the conversion using ``10800 s`` per step.\n\n    Returns\n    -------\n    rainfall_cube : iris.cube.Cube\n        Daily precipitation totals aggregated over 09Z\u201309Z windows.\n        The cube has:\n          - ``standard_name`` set to ``'precipitation_amount'``\n          - ``long_name`` set to ``'Daily Total Precipitation Amount'``\n          - ``units`` set to ``'mm'``\n        The auxiliary categorisation coordinate is removed before returning.\n\n    Notes\n    -----\n    - Conversion to millimetres assumes 3-hourly time steps and rate units of\n      ``kg m-2 s-1``: for each step, amount = rate \u00d7 10800 s, and\n      ``1 kg m-2 == 1 mm`` water equivalent.\n    - The first and last bins are sliced off (``[1:-1]``) to avoid partial days.\n    - The internal day labels are placed at 21:00 UTC corresponding to the\n      end of each 09Z\u201309Z window.\n    \"\"\"\n\t# Create coordinates categorisation function for days bewteen 09Z09.\n\tdef day_09z09(cube, coord, name=\"day_09z09\"):\n\t\tdef _get_day(coord, value):\n\t\t\t# Get specific timestep as datetime object.\n\t\t\tdate = coord.units.num2date(value)\n\n\t\t\t# Define on day N at 09:00.\n\t\t\tref = datetime(\n\t\t\t\tdate.year, date.month, date.day, 9\n\t\t\t)\n\n\t\t\t# Determine which day it falls within.\n\t\t\tif date &gt;= ref:\n\t\t\t\tday = datetime(date.year, date.month, date.day, 21)\n\t\t\telse:\n\t\t\t\tday = datetime(\n\t\t\t\t\tdate.year, date.month, date.day, 21\n\t\t\t\t) - timedelta(days=+1) \n\n\t\t\treturn coord.units.date2num(day)\n\n\t\tadd_categorised_coord(cube, name, coord, _get_day)\n\n\t# Add coordinates categorisation to cube.\n\tday_09z09(pr_cube_input, pr_cube_input.coord(\"time\"))\n\tpr_cube_input.coord(\"day_09z09\").units = pr_cube_input.coord(\"time\").units\n\n\t# Calculate rainfall accumulation.\n\trainfall_cube = pr_cube_input.aggregated_by(\"day_09z09\", iris.analysis.SUM)[1:-1]\n\n\t# Convert units to mm and change standard name.\n\trainfall_cube *= 10800\n\trainfall_cube.standard_name = \"precipitation_amount\"\n\trainfall_cube.long_name = \"Daily Total Precipitation Amount\"\n\trainfall_cube.units = \"mm\"\n\n\t# Remove extra coordinates.\n\trainfall_cube.remove_coord(\"day_09z09\")\n\n\treturn rainfall_cube\n</code></pre>"},{"location":"api/#master.create_rectilinear_cube","title":"create_rectilinear_cube","text":"<pre><code>create_rectilinear_cube(lon_min, lon_max, lat_min, lat_max, res=0.1)\n</code></pre> <p>Create a dummy Iris cube on a rectilinear latitude\u2013longitude grid.</p> <p>The function generates evenly spaced latitude and longitude points between given bounds at the specified resolution, then builds a  2D cube with zero-filled data on that grid. The cube can be used  as a template or target grid for regridding operations.</p> <p>Parameters:</p> Name Type Description Default <code>lon_min</code> <code>float</code> <p>Minimum longitude of the grid (degrees east).</p> required <code>lon_max</code> <code>float</code> <p>Maximum longitude of the grid (degrees east). The range is half-open: the last grid point is strictly less than <code>lon_max</code>.</p> required <code>lat_min</code> <code>float</code> <p>Minimum latitude of the grid (degrees north).</p> required <code>lat_max</code> <code>float</code> <p>Maximum latitude of the grid (degrees north). The range is half-open: the last grid point is strictly less than <code>lat_max</code>.</p> required <code>res</code> <code>float</code> <p>Grid spacing in degrees for both latitude and longitude. Default is 0.1 degrees.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>dummy_cube</code> <code>Cube</code> <p>A 2D cube of zeros with latitude and longitude as dimension coordinates. Units are degrees, with a geographic coordinate system (<code>GeogCS</code>) defined.</p> Notes <ul> <li>The dummy data array is filled with zeros and has shape    <code>(n_lat, n_lon)</code>.</li> <li>Longitude and latitude arrays are generated with    <code>numpy.arange(start, stop, res)</code>, so the upper bounds   (<code>lon_max</code>, <code>lat_max</code>) are exclusive.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_rectilinear_cube(lon_min, lon_max, lat_min, lat_max, res=0.1):\n\t\"\"\"\n    Create a dummy Iris cube on a rectilinear latitude\u2013longitude grid.\n\n    The function generates evenly spaced latitude and longitude points\n    between given bounds at the specified resolution, then builds a \n    2D cube with zero-filled data on that grid. The cube can be used \n    as a template or target grid for regridding operations.\n\n    Parameters\n    ----------\n    lon_min : float\n        Minimum longitude of the grid (degrees east).\n    lon_max : float\n        Maximum longitude of the grid (degrees east). The range is\n        half-open: the last grid point is strictly less than `lon_max`.\n    lat_min : float\n        Minimum latitude of the grid (degrees north).\n    lat_max : float\n        Maximum latitude of the grid (degrees north). The range is\n        half-open: the last grid point is strictly less than `lat_max`.\n    res : float, optional\n        Grid spacing in degrees for both latitude and longitude.\n        Default is 0.1 degrees.\n\n    Returns\n    -------\n    dummy_cube : iris.cube.Cube\n        A 2D cube of zeros with latitude and longitude as dimension\n        coordinates. Units are degrees, with a geographic coordinate\n        system (`GeogCS`) defined.\n\n    Notes\n    -----\n    - The dummy data array is filled with zeros and has shape \n      `(n_lat, n_lon)`.\n    - Longitude and latitude arrays are generated with \n      ``numpy.arange(start, stop, res)``, so the upper bounds\n      (`lon_max`, `lat_max`) are **exclusive**.\n    \"\"\"\n\t# Define coordinates.\n\tlat_points = np.arange(lat_min, lat_max, res)      \n\tlon_points = np.arange(lon_min, lon_max, res)  \n\n\tlatitude = iris.coords.DimCoord(\n\t\tlat_points, standard_name='latitude', units='degrees',\n\t\tcoord_system=iris.coord_systems.GeogCS(iris.fileformats.pp.EARTH_RADIUS)\n\t)\n\tlongitude = iris.coords.DimCoord(\n\t\tlon_points, standard_name='longitude', units='degrees',\n\t\tcoord_system=iris.coord_systems.GeogCS(iris.fileformats.pp.EARTH_RADIUS)\n\t)\n\n\t# Create a dummy cube with the target grid.\n\tdummy_data = np.zeros((len(lat_points), len(lon_points)))\n\tdummy_cube = iris.cube.Cube(\n\t\tdummy_data,\n\t\tdim_coords_and_dims=[\n\t\t\t(latitude, 0),\n\t\t\t(longitude, 1)\n\t\t],\n\t)\n\n\treturn dummy_cube\n</code></pre>"},{"location":"api/#master.regrid_cube","title":"regrid_cube","text":"<pre><code>regrid_cube(basis_cube, target_cube, scheme='bilinear')\n</code></pre> <p>Regrid a cube onto the grid of another cube.</p> <p>Currently only supports bilinear interpolation using the ESMF regridding scheme.</p> <p>Parameters:</p> Name Type Description Default <code>basis_cube</code> <code>Cube</code> <p>The reference cube that defines the target grid  (lat/lon resolution, extent, coordinate system).</p> required <code>target_cube</code> <code>Cube</code> <p>The input cube to be regridded to the grid of <code>basis_cube</code>.</p> required <code>scheme</code> <code>bilinear</code> <p>Regridding scheme to use. Currently only <code>'bilinear'</code> is supported, which applies <code>ESMFBilinear</code>. Default is <code>'bilinear'</code>.</p> <code>'bilinear'</code> <p>Returns:</p> Name Type Description <code>regridded_cube</code> <code>Cube</code> <p>The regridded cube on the grid of <code>basis_cube</code>.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If a scheme other than <code>'bilinear'</code> is specified.</p> Source code in <code>master.py</code> <pre><code>def regrid_cube(basis_cube, target_cube, scheme=\"bilinear\"):\n\t\"\"\"\n    Regrid a cube onto the grid of another cube.\n\n    Currently only supports bilinear interpolation using the\n    ESMF regridding scheme.\n\n    Parameters\n    ----------\n    basis_cube : iris.cube.Cube\n        The reference cube that defines the target grid \n        (lat/lon resolution, extent, coordinate system).\n    target_cube : iris.cube.Cube\n        The input cube to be regridded to the grid of `basis_cube`.\n    scheme : {'bilinear'}, optional\n        Regridding scheme to use. Currently only ``'bilinear'`` is supported,\n        which applies `ESMFBilinear`. Default is ``'bilinear'``.\n\n    Returns\n    -------\n    regridded_cube : iris.cube.Cube\n        The regridded cube on the grid of `basis_cube`.\n\n    Raises\n    ------\n    NotImplementedError\n        If a scheme other than ``'bilinear'`` is specified.\n    \"\"\"\n\t# Regrid target cube to basis cube coordinates.\n\tif scheme == \"bilinear\":\n\t\treturn target_cube.regrid(basis_cube, ESMFBilinear())\n\telse:\n\t\traise NotImplementedError(\"Other regridding methods have not been implemented.\")\n</code></pre>"},{"location":"api/#master.extract_common_period","title":"extract_common_period","text":"<pre><code>extract_common_period(cubes)\n</code></pre> <p>Extract the common overlapping time period across multiple cubes.</p> <p>This function ensures all cubes use a standard calendar, unifies their  time units, determines the maximum overlapping time range, and returns  each cube constrained to that period.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of iris.cube.Cube</code> <p>Input cubes with a <code>time</code> coordinate. Each cube may have  different time ranges, calendars, or units.</p> required <p>Returns:</p> Name Type Description <code>constrained_cubes</code> <code>list of iris.cube.Cube</code> <p>List of cubes extracted to the common overlapping time period. Each cube has unified time units and standard calendar.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no overlapping time period exists between the cubes.</p> <code>CoordinateNotFoundError</code> <p>If a cube does not have a <code>time</code> coordinate.</p> Source code in <code>master.py</code> <pre><code>def extract_common_period(cubes):\n\t\"\"\"\n    Extract the common overlapping time period across multiple cubes.\n\n    This function ensures all cubes use a standard calendar, unifies their \n    time units, determines the maximum overlapping time range, and returns \n    each cube constrained to that period.\n\n    Parameters\n    ----------\n    cubes : list of iris.cube.Cube\n        Input cubes with a ``time`` coordinate. Each cube may have \n        different time ranges, calendars, or units.\n\n    Returns\n    -------\n    constrained_cubes : list of iris.cube.Cube\n        List of cubes extracted to the common overlapping time period.\n        Each cube has unified time units and standard calendar.\n\n    Raises\n    ------\n    ValueError\n        If no overlapping time period exists between the cubes.\n    iris.exceptions.CoordinateNotFoundError\n        If a cube does not have a ``time`` coordinate.\n    \"\"\"\n\t# Loop through each cube.\n\tcommon_calendar_cubes = []\n\tfor cube in cubes:\n\t\t# Convert to standard calendar.\n\t\tcube.coord(\"time\").units = cf_units.Unit(\n\t\t\tcube.coord(\"time\").units.origin, calendar=\"standard\"\n\t\t)\n\t\tcommon_calendar_cubes.append(cube)\n\n\t# Unify time units.\n\tunified_cubes = iris.cube.CubeList(common_calendar_cubes)\n\tunify_time_units(unified_cubes)\n\n\t# Extract the time coordinates for all cubes\n\ttime_ranges = []\n\n\t#\u00a0Loop through to get start and end dates.\n\tfor cube in unified_cubes:\n\t\t# Get time coordinate.\n\t\ttime_coord = cube.coord(\"time\")\n\n\t\t# Get points.\n\t\ttimes = time_coord.units.num2date(time_coord.points)\n\n\t\t#\u00a0Append start and end dates.\n\t\ttime_ranges.append((times[0], times[-1]))\n\n    # Compute the max start time and min end time\n\tstart_times, end_times = zip(*time_ranges)\n\tcommon_start = max(start_times)\n\tcommon_end = min(end_times)\n\n\t# Raise error if there is not overlap.\n\tif common_start &gt;= common_end:\n\t\traise ValueError(\"No overlapping time period found across cubes.\")\n\n\t# Create constraint.\n\tconstraint = iris.Constraint(\n\t\ttime=lambda cell: common_start &lt;= cell.point &lt;= common_end\n\t)\n\n\t#\u00a0Define constrained cubes\n\tconstrained_cubes = []\n\tfor cube in unified_cubes:\n\t\t# Extract relevant period.\n\t\tconstrained_cube = cube.extract(constraint)\n\n\t\t# Append to list.\n\t\tconstrained_cubes.append(constrained_cube)\n\n\treturn constrained_cubes\n</code></pre>"},{"location":"api/#master.add_statistical_information","title":"add_statistical_information","text":"<pre><code>add_statistical_information(cube_data, unit, ax)\n</code></pre> <p>Add basic statistical information as annotations on a plot.</p> <p>Computes and displays mean absolute value, standard deviation, and mean bias of the input data, then adds them as anchored text boxes to the provided Matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>cube_data</code> <code>array_like</code> <p>Input data array (e.g., model errors, residuals). Can be any  NumPy-compatible sequence of values.</p> required <code>unit</code> <code>str</code> <p>String label for the physical unit of the data (e.g., 'K', 'mm').</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis object to which the annotations will be added.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully adding the annotations.</p> Notes <ul> <li> <p>Statistics added to the axis:</p> </li> <li> <p>Mean absolute value: :math:<code>|\bar{x}|</code> </p> </li> <li>Standard deviation: :math:<code>s</code> (with Bessel's correction, ddof=1)  </li> <li> <p>Mean bias: :math:<code>\bar{x}</code> </p> </li> <li> <p>Anchored positions:</p> </li> <li> <p>Mean absolute value and standard deviation \u2192 bottom-right (loc=4).  </p> </li> <li>Mean bias \u2192 top-left (loc=2).  </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; data = np.random.randn(100)\n&gt;&gt;&gt; add_statistical_information(data, 'K', ax)\nTrue\n</code></pre> Source code in <code>master.py</code> <pre><code>def add_statistical_information(cube_data, unit, ax):\n\t\"\"\"\n    Add basic statistical information as annotations on a plot.\n\n    Computes and displays mean absolute value, standard deviation,\n    and mean bias of the input data, then adds them as anchored text\n    boxes to the provided Matplotlib axis.\n\n    Parameters\n    ----------\n    cube_data : array_like\n        Input data array (e.g., model errors, residuals). Can be any \n        NumPy-compatible sequence of values.\n    unit : str\n        String label for the physical unit of the data (e.g., 'K', 'mm').\n    ax : matplotlib.axes.Axes\n        Matplotlib axis object to which the annotations will be added.\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully adding the annotations.\n\n    Notes\n    -----\n    - Statistics added to the axis:\n\n      * **Mean absolute value**: :math:`|\\bar{x}|`  \n      * **Standard deviation**: :math:`s` (with Bessel's correction, ddof=1)  \n      * **Mean bias**: :math:`\\bar{x}`  \n\n    - Anchored positions:\n\n      * Mean absolute value and standard deviation \u2192 bottom-right (loc=4).  \n      * Mean bias \u2192 top-left (loc=2).  \n\n    Examples\n    --------\n    &gt;&gt;&gt; fig, ax = plt.subplots()\n    &gt;&gt;&gt; data = np.random.randn(100)\n    &gt;&gt;&gt; add_statistical_information(data, 'K', ax)\n    True\n    \"\"\"\n\t# Calculate relevant statistical information.\n\t# Calculate mean absolute error.\n\ttxt_cube = r'$|\\bar{x}| = $' + '{} {}\\n'.format(\n\t\tnp.round(np.mean(np.abs(cube_data)), 2), unit\n\t)\n\t# Calculate standard deviation.\n\ttxt_cube += r'$s = $' + '{} {}'.format(\n\t\tnp.round(np.std(np.abs(cube_data), ddof=1), 2), unit\n\t)\n\t# Calculate mean bias.\n\ttxt_cube_bias = r'$\\bar{x} = $' + '{} {}'.format(\n\t\tnp.round(float(np.mean(cube_data)), 2), unit\n\t)\n\n\t# Add to plots.\n\t# Lower right hand side.\n\tax.add_artist(AnchoredText(txt_cube, loc=4))\n\t# Top left hand side.\n\tax.add_artist(AnchoredText(txt_cube_bias, loc=2))\n\n\treturn True\n</code></pre>"},{"location":"api/#master.plot_dist","title":"plot_dist","text":"<pre><code>plot_dist(ds, title, subtitles, nbins, xlabel, unit, fname, size, xlim=None, ylim=None)\n</code></pre> <p>Plot histograms of multiple Iris cubes in a grid layout with statistical annotations.</p> <p>Each subplot corresponds to one cube, drawn as a histogram of its flattened data values with the specified number of bins. Titles, labels, axis limits, and statistical information (mean absolute value, standard deviation, and mean bias) are added to each subplot. The entire figure is saved to file.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of Iris cubes. Each element <code>ds[i][j]</code> is an Iris cube; its <code>.data</code> values are flattened into a histogram.</p> required <code>title</code> <code>str</code> <p>Main title for the entire figure (suptitle).</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>ds</code>. <code>subtitles[i][j]</code> is the title for subplot (i, j).</p> required <code>nbins</code> <code>int</code> <p>Number of bins to use in each histogram.</p> required <code>xlabel</code> <code>str</code> <p>Label for the x-axis of each subplot.</p> required <code>unit</code> <code>str</code> <p>Unit string to display in statistical annotations (e.g., 'K', 'mm').</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <code>xlim</code> <code>tuple of float</code> <p>x-axis limits as (xmin, xmax). Default is None (auto-scaled).</p> <code>None</code> <code>ylim</code> <code>tuple of float</code> <p>y-axis limits as (ymin, ymax). Default is None (auto-scaled).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Source code in <code>master.py</code> <pre><code>def plot_dist(ds, title, subtitles, nbins, xlabel, unit, fname, size, xlim=None, ylim=None):\n\t\"\"\"\n    Plot histograms of multiple Iris cubes in a grid layout with statistical annotations.\n\n    Each subplot corresponds to one cube, drawn as a histogram of its flattened\n    data values with the specified number of bins. Titles, labels, axis limits,\n    and statistical information (mean absolute value, standard deviation, and mean bias)\n    are added to each subplot. The entire figure is saved to file.\n\n    Parameters\n    ----------\n    ds : list of list of iris.cube.Cube\n        Nested list (2D structure) of Iris cubes. Each element `ds[i][j]` is an\n        Iris cube; its `.data` values are flattened into a histogram.\n    title : str\n        Main title for the entire figure (suptitle).\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `ds`. `subtitles[i][j]` is the title\n        for subplot (i, j).\n    nbins : int\n        Number of bins to use in each histogram.\n    xlabel : str\n        Label for the x-axis of each subplot.\n    unit : str\n        Unit string to display in statistical annotations (e.g., 'K', 'mm').\n    fname : str\n        Path (including filename) where the figure will be saved.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n    xlim : tuple of float, optional\n        x-axis limits as (xmin, xmax). Default is None (auto-scaled).\n    ylim : tuple of float, optional\n        y-axis limits as (ymin, ymax). Default is None (auto-scaled).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\t\"\"\"\n\t# Determine number of rows.\n\tnrows = len(ds)\n\tncols = len(ds[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(nrows, ncols, dpi=300, tight_layout=True)\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\tfor j in range(ncols):\n\t\t\t# Create histogram.\n\t\t\taxs[i][j].hist(ds[i][j].data.flatten(), bins=nbins)\n\n\t\t\t# Add subplot title.\n\t\t\taxs[i][j].set_title(subtitles[i][j])\n\n\t\t\t# Set axis label.\n\t\t\taxs[i][j].set_xlabel(xlabel)\n\n\t\t\t# Set axes limit.\n\t\t\tif xlim != None:\n\t\t\t\t# x-axis.\n\t\t\t\taxs[i][j].set_xlim(xlim)\n\t\t\tif ylim != None:\n\t\t\t\t# y-axis.\n\t\t\t\taxs[i][j].set_ylim(xlim)\n\n\t\t\t# Remove ytick labels.\n\t\t\taxs[i][j].set_yticklabels([])\n\n\t\t\t# Add statistical information.\n\t\t\tadd_statistical_information(ds[i][j].data, unit, axs[i][j])\n\n\t# Add title.\n\tfig.suptitle(title, weight='bold')\n\n\t# Change size.\n\tfig.set_size_inches(size)\n\n\t# Save result.\n\tplt.savefig(fname)\n\n\t# Output information.\n\tprint(\"Created distribution successfully\")\n\n\treturn True\n</code></pre>"},{"location":"api/#master.plot_series","title":"plot_series","text":"<pre><code>plot_series(cubes, operation, title, labels, ylabel, fname)\n</code></pre> <p>Plot time series of spatially aggregated Iris cubes.</p> <p>Each input cube is collapsed over latitude and longitude using the specified aggregation operation, producing a single time series per cube. The resulting series are plotted together with labels, a title, and y-axis label, and the figure is saved to file.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of iris.cube.Cube</code> <p>List of Iris cubes, each containing a <code>time</code> coordinate and  2D spatial coordinates <code>latitude</code> and <code>longitude</code>.</p> required <code>operation</code> <code>function</code> <p>Aggregation function used in the collapse, e.g.  <code>iris.analysis.MEAN</code> or <code>iris.analysis.SUM</code>.</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> required <code>labels</code> <code>list of str</code> <p>Labels for the plotted time series, one per cube.</p> required <code>ylabel</code> <code>str</code> <p>Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/day)').</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Notes <ul> <li>The series are collapsed spatially over <code>['longitude', 'latitude']</code>.</li> <li>The x-axis is formatted for dates automatically.</li> <li>The output is saved at 300 dpi.</li> </ul> Source code in <code>master.py</code> <pre><code>def plot_series(cubes, operation, title, labels, ylabel, fname):\n\t\"\"\"\n    Plot time series of spatially aggregated Iris cubes.\n\n    Each input cube is collapsed over latitude and longitude using the\n    specified aggregation operation, producing a single time series per cube.\n    The resulting series are plotted together with labels, a title, and y-axis\n    label, and the figure is saved to file.\n\n    Parameters\n    ----------\n    cubes : list of iris.cube.Cube\n        List of Iris cubes, each containing a ``time`` coordinate and \n        2D spatial coordinates ``latitude`` and ``longitude``.\n    operation : function\n        Aggregation function used in the collapse, e.g. \n        ``iris.analysis.MEAN`` or ``iris.analysis.SUM``.\n    title : str\n        Title for the plot.\n    labels : list of str\n        Labels for the plotted time series, one per cube.\n    ylabel : str\n        Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/day)').\n    fname : str\n        Path (including filename) where the figure will be saved.\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Notes\n    -----\n    - The series are collapsed spatially over ``['longitude', 'latitude']``.\n    - The x-axis is formatted for dates automatically.\n    - The output is saved at 300 dpi.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\t# Calculate mean spatial mean at each timestep.\n\t\tseries_cube = cubes[i].collapsed(\n\t\t\t['longitude', 'latitude'], operation\n\t\t)\n\n\t\t# Create plot.\n\t\tiplt.plot(series_cube, label=labels[i])\n\n\t# Deal with x-axis ticks.\n\tplt.gcf().autofmt_xdate()\n\n\t# Set axis label.\n\tplt.ylabel(ylabel)\n\n\t# Put a grid on the plot.\n\tplt.grid(True)\n\n\t#\u00a0Add legend.\n\tplt.legend(loc=0)\n\n\t# Add title.\n\tplt.title(title, weight='bold')\n\n\t# Save result.\n\tplt.savefig(fname, dpi=300)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.plot_diurnal_cycle","title":"plot_diurnal_cycle","text":"<pre><code>plot_diurnal_cycle(cubes, operation, title, labels, ylabel, fname)\n</code></pre> <p>Plot the diurnal cycle of one or more Iris cubes.</p> <p>For each cube, the function bins data by hour of the day (from the <code>time</code> coordinate), applies the specified aggregation operation within each hour, collapses over spatial dimensions, and plots the resulting hourly cycle. The figure is saved to file.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of iris.cube.Cube</code> <p>List of Iris cubes, each containing a <code>time</code> coordinate and 2D spatial coordinates <code>latitude</code> and <code>longitude</code>.</p> required <code>operation</code> <code>function</code> <p>Aggregation function used for both hourly grouping and spatial  collapse, e.g. <code>iris.analysis.MEAN</code>, <code>iris.analysis.SUM</code>, <code>iris.analysis.MAX</code>, etc.</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> required <code>labels</code> <code>list of str</code> <p>Labels for each plotted diurnal cycle, one per cube.</p> required <code>ylabel</code> <code>str</code> <p>Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/hr)').</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Notes <ul> <li>The <code>hour</code> coordinate is added dynamically via    :func:<code>iris.coord_categorisation.add_hour</code>.</li> <li>Each cube is collapsed spatially over <code>['latitude', 'longitude']</code>    using the provided <code>operation</code>.</li> <li>The x-axis runs from 0\u201323 hours.</li> <li>The figure is saved at 300 dpi.</li> </ul> Source code in <code>master.py</code> <pre><code>def plot_diurnal_cycle(cubes, operation, title, labels, ylabel, fname):\n\t\"\"\"\n    Plot the diurnal cycle of one or more Iris cubes.\n\n    For each cube, the function bins data by hour of the day (from the ``time``\n    coordinate), applies the specified aggregation operation within each hour,\n    collapses over spatial dimensions, and plots the resulting hourly cycle.\n    The figure is saved to file.\n\n    Parameters\n    ----------\n    cubes : list of iris.cube.Cube\n        List of Iris cubes, each containing a ``time`` coordinate and\n        2D spatial coordinates ``latitude`` and ``longitude``.\n    operation : function\n        Aggregation function used for both hourly grouping and spatial \n        collapse, e.g. ``iris.analysis.MEAN``, ``iris.analysis.SUM``,\n        ``iris.analysis.MAX``, etc.\n    title : str\n        Title for the plot.\n    labels : list of str\n        Labels for each plotted diurnal cycle, one per cube.\n    ylabel : str\n        Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/hr)').\n    fname : str\n        Path (including filename) where the figure will be saved.\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Notes\n    -----\n    - The ``hour`` coordinate is added dynamically via \n      :func:`iris.coord_categorisation.add_hour`.\n    - Each cube is collapsed spatially over ``['latitude', 'longitude']`` \n      using the provided `operation`.\n    - The x-axis runs from 0\u201323 hours.\n    - The figure is saved at 300 dpi.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\n\t# Get timesteps for x-axis.\n\tcube_time = cubes[0].coord(\"time\")\n\tsteps = cube_time.units.num2date(cube_time.points)\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\t#\u00a0Get cube.\n\t\tcube = cubes[i]\n\n\t\t# Add an 'hour' coordinate to the cube\n\t\tiris.coord_categorisation.add_hour(cube, \"time\", name=\"hour\")\n\n\t\t# Calculate mean spatial mean at each timestep.\n\t\tdiurnal_cycle = cube.aggregated_by(\"hour\", operation)\n\n\t\t# Collapse spatial dimensions to get mean temperature for each hour\n\t\tdiurnal_operation = diurnal_cycle.collapsed(\n\t\t\t['latitude', 'longitude'], operation\n\t\t)\n\n\t\t#\u00a0Get time.\n\t\tt = diurnal_operation.coord(\"hour\").points\n\n\t\t# Create plot.\n\t\tplt.plot(t, diurnal_operation.data, label=labels[i])\n\n\t# Set axis labels.\n\tplt.xlabel(\"Hour\")\n\tplt.ylabel(ylabel)\n\n\t#\u00a0Add legend.\n\tplt.legend(loc=0)\n\n\t# Add title.\n\tplt.title(title, weight='bold')\n\n\t# Save result.\n\tplt.savefig(fname, dpi=300)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.find_nearest_grid_point","title":"find_nearest_grid_point","text":"<pre><code>find_nearest_grid_point(cube, target_lat, target_lon, max_search_radius=5)\n</code></pre> <p>Extract the time series at the nearest valid grid point to a target lat/lon.</p> <p>The function first finds the nearest latitude/longitude indices to the target. If the corresponding grid cell has valid data (not masked/NaN) in the first time slice, it returns that time series. Otherwise, it searches within a square neighborhood around the initial index (up to <code>max_search_radius</code> grid cells away in each direction) and returns the time series at the closest valid grid cell to the target coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>Cube</code> <p>Data cube with dimensions ordered as <code>(time, latitude, longitude)</code>. The first time slice is used to determine validity (mask/NaN).</p> required <code>target_lat</code> <code>float</code> <p>Target latitude in degrees north.</p> required <code>target_lon</code> <code>float</code> <p>Target longitude in degrees east (same convention/range as the cube).</p> required <code>max_search_radius</code> <code>int</code> <p>Maximum search radius in grid cells around the initial nearest index, used only if the initial point is invalid. Default is <code>5</code>.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>time_series</code> <code>Cube</code> <p>A 1D cube (over <code>time</code>) extracted at the selected grid cell.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid grid point is found within the search neighborhood.</p> Notes <ul> <li>Validity is checked on the first time slice only.</li> <li>Distance is computed in index space using a simple Euclidean metric on   lat/lon degrees (<code>np.hypot</code>). For small neighborhoods this is adequate.</li> <li><code>max_search_radius</code> is in index units, not degrees. For example,   if your grid spacing is 0.1\u00b0, a radius of 5 covers \u00b10.5\u00b0 around the   initial nearest-neighbor index.</li> </ul> Source code in <code>master.py</code> <pre><code>def find_nearest_grid_point(cube, target_lat, target_lon, max_search_radius=5):\n\t\"\"\"\n    Extract the time series at the nearest *valid* grid point to a target lat/lon.\n\n    The function first finds the nearest latitude/longitude indices to the target.\n    If the corresponding grid cell has valid data (not masked/NaN) in the first\n    time slice, it returns that time series. Otherwise, it searches within a\n    square neighborhood around the initial index (up to `max_search_radius`\n    grid cells away in each direction) and returns the time series at the closest\n    valid grid cell to the target coordinates.\n\n    Parameters\n    ----------\n    cube : iris.cube.Cube\n        Data cube with dimensions ordered as ``(time, latitude, longitude)``.\n        The first time slice is used to determine validity (mask/NaN).\n    target_lat : float\n        Target latitude in degrees north.\n    target_lon : float\n        Target longitude in degrees east (same convention/range as the cube).\n    max_search_radius : int, optional\n        Maximum search radius **in grid cells** around the initial nearest\n        index, used only if the initial point is invalid. Default is ``5``.\n\n    Returns\n    -------\n    time_series : iris.cube.Cube\n        A 1D cube (over ``time``) extracted at the selected grid cell.\n\n    Raises\n    ------\n    ValueError\n        If no valid grid point is found within the search neighborhood.\n\n    Notes\n    -----\n    - Validity is checked on the **first** time slice only.\n    - Distance is computed in index space using a simple Euclidean metric on\n      lat/lon degrees (``np.hypot``). For small neighborhoods this is adequate.\n    - `max_search_radius` is in **index units**, not degrees. For example,\n      if your grid spacing is 0.1\u00b0, a radius of 5 covers \u00b10.5\u00b0 around the\n      initial nearest-neighbor index.\n    \"\"\"\n\t#\u00a0Get longitude and latitude array.\n\tlats = cube.coord('latitude').points\n\tlons = cube.coord('longitude').points\n\n\t# Get initial index of nearest neighbour.\n\tlat_idx = np.abs(lats - target_lat).argmin()\n\tlon_idx = np.abs(lons - target_lon).argmin()\n\n\t#\u00a0Get the first time slice as data.\n\tdata = cube[0].data\n\n    # Check if that point has valid data\n\tif not np.ma.is_masked(data[lat_idx, lon_idx]) and not np.isnan(data[lat_idx, lon_idx]):\n\t\treturn cube[:, lat_idx, lon_idx]\n\n    # Otherwise, search within a neighbourhood\n\tlat_range = range(\n\t\tmax(0, lat_idx - max_search_radius), min(len(lats), lat_idx + max_search_radius + 1)\n\t)\n\tlon_range = range(\n\t\tmax(0, lon_idx - max_search_radius), min(len(lons), lon_idx + max_search_radius + 1)\n\t)\n\n\t#\u00a0Set minimum distance starting point.\n\tmin_dist = float('inf')\n\tbest_slice = None\n\n\t#\u00a0Loop through longitude and latitude range.\n\tfor i in lat_range:\n\t\tfor j in lon_range:\n\t\t\t# Check if data is masked or NaN at this new point.\n\t\t\tif not np.ma.is_masked(data[i, j]) and not np.isnan(data[i, j]):\n\t\t\t\t# If satisifed, calculated distance between target and valid point.\n\t\t\t\tdist = np.hypot(lats[i] - target_lat, lons[j] - target_lon)\n\n\t\t\t\t#\u00a0If the grid point is closer, save this point.\n\t\t\t\tif dist &lt; min_dist:\n\t\t\t\t\tmin_dist = dist\n\t\t\t\t\tbest_slice = cube[:, i, j]\n\n\t#\u00a0Only return if there is a valid grid point.\n\tif best_slice is not None:\n\t\treturn best_slice\n\telse:\n\t\traise ValueError(\"No valid grid point found near the target location.\")\n</code></pre>"},{"location":"api/#master.plot_location_series","title":"plot_location_series","text":"<pre><code>plot_location_series(cubes, title, labels, location_name, unit, fname, obs=None)\n</code></pre> <p>Plot time series from multiple Iris cubes at the grid point nearest to a named location.</p> <p>The function uses geocoding (via Nominatim) to resolve a place name into latitude/longitude, finds the nearest valid grid point in each cube, extracts the corresponding time series, and plots them together. An optional set of observational data can also be plotted for comparison.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of iris.cube.Cube</code> <p>List of Iris cubes, each with dimensions including time, latitude, and longitude.</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> required <code>labels</code> <code>list of str</code> <p>Labels for each cube's plotted time series, one per cube.</p> required <code>location_name</code> <code>str</code> <p>Place name to resolve to coordinates via geopy's Nominatim service. (Requires internet access.)</p> required <code>unit</code> <code>str</code> <p>Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/day)').</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <code>obs</code> <code>tuple of (array_like, array_like)</code> <p>Observational data to plot as <code>(times, values)</code>. - <code>obs[0]</code> : sequence of datetime-like values for the x-axis. - <code>obs[1]</code> : sequence of numerical values for the y-axis. Default is None (no observations plotted).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the <code>location_name</code> cannot be resolved to coordinates.</p> <code>ValueError</code> <p>If no valid grid point is found near the resolved location in a cube.</p> Notes <ul> <li>Location lookup uses OpenStreetMap's Nominatim service. Ensure network   access is available when running this function.</li> <li>Grid point selection relies on :func:<code>find_nearest_grid_point</code>.</li> <li>All time series are plotted on the same axis with a common y-label (<code>unit</code>).</li> <li>Observations, if provided, are added as an additional line labelled   \"Observations\".</li> </ul> Source code in <code>master.py</code> <pre><code>def plot_location_series(cubes, title, labels, location_name, unit, fname, obs=None):\n\t\"\"\"\n    Plot time series from multiple Iris cubes at the grid point nearest to a named location.\n\n    The function uses geocoding (via Nominatim) to resolve a place name into\n    latitude/longitude, finds the nearest valid grid point in each cube,\n    extracts the corresponding time series, and plots them together. An\n    optional set of observational data can also be plotted for comparison.\n\n    Parameters\n    ----------\n    cubes : list of iris.cube.Cube\n        List of Iris cubes, each with dimensions including time, latitude, and longitude.\n    title : str\n        Title for the plot.\n    labels : list of str\n        Labels for each cube's plotted time series, one per cube.\n    location_name : str\n        Place name to resolve to coordinates via geopy's Nominatim service.\n        (Requires internet access.)\n    unit : str\n        Label for the y-axis (e.g., 'Temperature (K)', 'Precipitation (mm/day)').\n    fname : str\n        Path (including filename) where the figure will be saved.\n    obs : tuple of (array_like, array_like), optional\n        Observational data to plot as ``(times, values)``.\n        - ``obs[0]`` : sequence of datetime-like values for the x-axis.\n        - ``obs[1]`` : sequence of numerical values for the y-axis.\n        Default is None (no observations plotted).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Raises\n    ------\n    Exception\n        If the `location_name` cannot be resolved to coordinates.\n    ValueError\n        If no valid grid point is found near the resolved location in a cube.\n\n    Notes\n    -----\n    - Location lookup uses OpenStreetMap's Nominatim service. Ensure network\n      access is available when running this function.\n    - Grid point selection relies on :func:`find_nearest_grid_point`.\n    - All time series are plotted on the same axis with a common y-label (`unit`).\n    - Observations, if provided, are added as an additional line labelled\n      \"Observations\".\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\n\t# Create a geolocator object with a user agent (can be any name)\n\tgeolocator = Nominatim(user_agent=\"cocathasaigh\")\n\n\t# Enter place name\n\tlocation = geolocator.geocode(location_name)\n\n\t# Check if location was found.\n\tif not location:\n\t\traise Exception(\"Location not found.\")\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\t# Retrieve cube point closet to location.\n\t\tnearest_cube_point = find_nearest_grid_point(\n\t\t\tcube=cubes[i], \n\t\t\ttarget_lat=location.latitude, \n\t\t\ttarget_lon=location.longitude\n\t\t)\n\n\t\t# Plot point.\n\t\tiplt.plot(nearest_cube_point, label=labels[i])\n\n\t# Deal with x-axis ticks.\n\tplt.gcf().autofmt_xdate()\n\n\t# Set axis label.\n\tplt.ylabel(unit)\n\n\t#\u00a0Add observations.\n\tif obs is not None:\n\t\tplt.plot(obs[0], obs[1], label=\"Observations\")\n\n\t# Add title.\n\tplt.title(\"{}\\n{}\".format(title, location_name), weight='bold')\n\n\t#\u00a0Add legend.\n\tplt.legend(loc=0)\n\n\t#\u00a0Add grid.\n\tplt.grid(True)\n\n\t# Save result.\n\tplt.savefig(fname, dpi=300)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.rainfall_cmap","title":"rainfall_cmap","text":"<pre><code>rainfall_cmap()\n</code></pre> <p>Construct a custom colormap and contour levels for rainfall visualisation.</p> <p>The function defines a sequence of precipitation thresholds (in mm) and a corresponding set of RGB colors. A <code>ListedColormap</code> is built and returned together with the contour levels.</p> <p>Returns:</p> Name Type Description <code>cmap</code> <code>ListedColormap</code> <p>Colormap for rainfall, labelled <code>\"precipitation\"</code>.</p> <code>clevs</code> <code>list of float</code> <p>Contour levels (mm) to be used with the colormap.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the number of contour levels and colors are inconsistent.</p> Notes <ul> <li>Thresholds (<code>clevs</code>) include:   [0, 0.1, 1, 2.5, 5, 7.5, 10, 15, 20, 25, 30, 40, 50, 70, 100, 150, 200, 250].</li> <li>Colors progress from white (low values) through cyan, green, yellow,   orange, red, magenta, purple, gray, to beige (high values).</li> <li>Designed for use in filled contour plots of accumulated precipitation.</li> </ul> Source code in <code>master.py</code> <pre><code>def rainfall_cmap():\n\t\"\"\"\n    Construct a custom colormap and contour levels for rainfall visualisation.\n\n    The function defines a sequence of precipitation thresholds (in mm)\n    and a corresponding set of RGB colors. A `ListedColormap` is built\n    and returned together with the contour levels.\n\n    Returns\n    -------\n    cmap : matplotlib.colors.ListedColormap\n        Colormap for rainfall, labelled `\"precipitation\"`.\n    clevs : list of float\n        Contour levels (mm) to be used with the colormap.\n\n    Raises\n    ------\n    AssertionError\n        If the number of contour levels and colors are inconsistent.\n\n    Notes\n    -----\n    - Thresholds (`clevs`) include:\n      [0, 0.1, 1, 2.5, 5, 7.5, 10, 15, 20, 25, 30, 40, 50, 70, 100, 150, 200, 250].\n    - Colors progress from white (low values) through cyan, green, yellow,\n      orange, red, magenta, purple, gray, to beige (high values).\n    - Designed for use in filled contour plots of accumulated precipitation.\n    \"\"\"\n\t# Draw filled contours.\n\tclevs = [\n\t\t0, 0.1, 1, 2.5, 5, 7.5, 10, 15, 20, 25, 30, 40, 50, 70, 100, 150, 200, 250\n\t]\n\n\t# Color map data.\n\tcmap_data = [\n\t\t(1.0, 1.0, 1.0),\n\t\t(0.3137255012989044, 0.8156862854957581, 0.8156862854957581),\n\t\t(0.0, 1.0, 1.0),\n\t\t(0.0, 0.8784313797950745, 0.501960813999176),\n\t\t(0.0, 0.7529411911964417, 0.0),\n\t\t(0.501960813999176, 0.8784313797950745, 0.0),\n\t\t(1.0, 1.0, 0.0),\n\t\t(1.0, 0.6274510025978088, 0.0),\n\t\t(1.0, 0.0, 0.0),\n\t\t(1.0, 0.125490203499794, 0.501960813999176),\n\t\t(0.9411764740943909, 0.250980406999588, 1.0),\n\t\t(0.501960813999176, 0.125490203499794, 1.0),\n\t\t(0.250980406999588, 0.250980406999588, 1.0),\n\t\t(0.125490203499794, 0.125490203499794, 0.501960813999176),\n\t\t(0.125490203499794, 0.125490203499794, 0.125490203499794),\n\t\t(0.501960813999176, 0.501960813999176, 0.501960813999176),\n\t\t(0.8784313797950745, 0.8784313797950745, 0.8784313797950745),\n\t\t(0.9333333373069763, 0.8313725590705872, 0.7372549176216125),\n\t\t#(0.8549019694328308, 0.6509804129600525, 0.47058823704719543),\n\t\t#(0.6274510025978088, 0.42352941632270813, 0.23529411852359772),\n\t\t#(0.4000000059604645, 0.20000000298023224, 0.0)\n\t]\n\n\t# Ensure the number of levels and the number of colours are equal.\n\tassert len(clevs) == len(cmap_data), \"Mismatch between the numbers of colours and numbers of levels\"\n\n\t# Create colour map.\n\tcmap = colors.ListedColormap(cmap_data, \"precipitation\")\n\n\treturn cmap, clevs\n</code></pre>"},{"location":"api/#master.prate_1hr_cmap","title":"prate_1hr_cmap","text":"<pre><code>prate_1hr_cmap()\n</code></pre> <p>Construct a custom colormap and contour levels for 1-hourly precipitation rate.</p> <p>The function defines a sequence of precipitation rate thresholds (in mm/hr) and a corresponding set of RGB colors. A <code>ListedColormap</code> is built and returned together with the contour levels.</p> <p>Returns:</p> Name Type Description <code>cmap</code> <code>ListedColormap</code> <p>Colormap for precipitation rate, labelled <code>\"precipitation_rate\"</code>.</p> <code>clevs</code> <code>list of float</code> <p>Contour levels (mm/hr) to be used with the colormap.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the number of contour levels and colors are inconsistent.</p> Notes <ul> <li>Thresholds (<code>clevs</code>) include:   [0, 0.2, 0.5, 1, 1.5, 2, 4, 10, 25, 50, 100].</li> <li>Colors progress from white (no rain) through shades of cyan/blue,   then magenta/orange, to red (intense rainfall).</li> <li>Designed for use in filled contour plots of precipitation rate fields.</li> </ul> Source code in <code>master.py</code> <pre><code>def prate_1hr_cmap():\n\t\"\"\"\n    Construct a custom colormap and contour levels for 1-hourly precipitation rate.\n\n    The function defines a sequence of precipitation rate thresholds (in mm/hr)\n    and a corresponding set of RGB colors. A `ListedColormap` is built and\n    returned together with the contour levels.\n\n    Returns\n    -------\n    cmap : matplotlib.colors.ListedColormap\n        Colormap for precipitation rate, labelled `\"precipitation_rate\"`.\n    clevs : list of float\n        Contour levels (mm/hr) to be used with the colormap.\n\n    Raises\n    ------\n    AssertionError\n        If the number of contour levels and colors are inconsistent.\n\n    Notes\n    -----\n    - Thresholds (`clevs`) include:\n      [0, 0.2, 0.5, 1, 1.5, 2, 4, 10, 25, 50, 100].\n    - Colors progress from white (no rain) through shades of cyan/blue,\n      then magenta/orange, to red (intense rainfall).\n    - Designed for use in filled contour plots of precipitation rate fields.\n    \"\"\"\n\t# Draw filled contours.\n\tclevs = [\n\t\t0, 0.2, 0.5, 1, 1.5, 2, 4, 10, 25, 50, 100\n\t]\n\n\t# Color map data.\n\tcmap_data = [\n\t\t(1.0, 1.0, 1.0),\n\t\t(0.0, 1.0, 1.0),\n\t\t(0.0, 0.85, 1.0),\n\t\t(0.0, 0.73, 1.0),\n\t\t(0.0, 0.61, 1.0),\n\t\t(0.0, 0.49, 1.0),\n\t\t(0.0, 0.0, 1.0),\n\t\t(0.7, 0.0, 1.0),\n\t\t(1.0, 0.0, 1.0),\n\t\t(1.0, 0.5, 0.0),\n\t\t(1.0, 0.0, 0.0),\n\t]\n\n\t# Ensure the number of levels and the number of colours are equal.\n\tassert len(clevs) == len(cmap_data), \"Mismatch between the numbers of colours and numbers of levels\"\n\n\t# Create colour map.\n\tcmap = colors.ListedColormap(cmap_data, \"precipitation_rate\")\n\n\treturn cmap, clevs\n</code></pre>"},{"location":"api/#master.create_param_plot","title":"create_param_plot","text":"<pre><code>create_param_plot(cubes, title, subtitles, levels, unit, fname, size)\n</code></pre> <p>Create a grid of filled contour plots for meteorological parameters.</p> <p>Each subplot corresponds to one Iris cube, displayed on a Plate Carr\u00e9e map projection with coastlines and a title. The colormap and contour levels are chosen automatically based on the physical unit (e.g., rainfall, temperature, pressure).</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of Iris cubes to plot. Each cube must contain latitude and longitude coordinates.</p> required <code>title</code> <code>str</code> <p>Overall title for the figure (added as a suptitle).</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>cubes</code>.</p> required <code>levels</code> <code>list of float</code> <p>Contour levels to use for plotting (may be overridden depending on the chosen <code>unit</code>).</p> required <code>unit</code> <code>str</code> <p>Physical unit of the parameter (e.g., 'mm', 'mm/hr', 'K', 'hPa', 'm s-1'). Determines the colormap and normalisation.</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Notes <ul> <li>For rainfall ('mm') and precipitation rate ('mm/hr'), custom   colormaps are retrieved from <code>rainfall_cmap()</code> and   <code>prate_1hr_cmap()</code>, respectively, and a <code>BoundaryNorm</code> is applied.</li> <li> <p>For other parameters:</p> </li> <li> <p>'K' \u2192 <code>RdYlBu_r</code> (temperature)  </p> </li> <li>'hPa' \u2192 <code>rainbow</code> (pressure; contour levels downsampled by 3)  </li> <li>'m s-1' \u2192 <code>jet</code> (wind speed)  </li> <li> <p>everything else \u2192 <code>viridis</code> </p> </li> <li> <p>A horizontal colorbar is added below the subplots with the unit   as the label.</p> </li> <li>Coastlines are drawn with 10m resolution.</li> <li>If the longitude/latitude coordinates are already 2D (curvilinear grid),   they are used directly instead of creating a meshgrid.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_param_plot(cubes, title, subtitles, levels, unit, fname, size):\n\t\"\"\"\n    Create a grid of filled contour plots for meteorological parameters.\n\n    Each subplot corresponds to one Iris cube, displayed on a\n    Plate Carr\u00e9e map projection with coastlines and a title.\n    The colormap and contour levels are chosen automatically\n    based on the physical unit (e.g., rainfall, temperature, pressure).\n\n    Parameters\n    ----------\n    cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of Iris cubes to plot. Each cube must\n        contain latitude and longitude coordinates.\n    title : str\n        Overall title for the figure (added as a suptitle).\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `cubes`.\n    levels : list of float\n        Contour levels to use for plotting (may be overridden depending\n        on the chosen `unit`).\n    unit : str\n        Physical unit of the parameter (e.g., 'mm', 'mm/hr', 'K', 'hPa', 'm s-1').\n        Determines the colormap and normalisation.\n    fname : str\n        Path (including filename) where the figure will be saved.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Notes\n    -----\n    - For rainfall ('mm') and precipitation rate ('mm/hr'), custom\n      colormaps are retrieved from `rainfall_cmap()` and\n      `prate_1hr_cmap()`, respectively, and a `BoundaryNorm` is applied.\n    - For other parameters:\n\n      * 'K' \u2192 ``RdYlBu_r`` (temperature)  \n      * 'hPa' \u2192 ``rainbow`` (pressure; contour levels downsampled by 3)  \n      * 'm s-1' \u2192 ``jet`` (wind speed)  \n      * everything else \u2192 ``viridis``  \n\n    - A horizontal colorbar is added below the subplots with the unit\n      as the label.\n    - Coastlines are drawn with 10m resolution.\n    - If the longitude/latitude coordinates are already 2D (curvilinear grid),\n      they are used directly instead of creating a meshgrid.\n\t\"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\tncols = len(cubes[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(\n\t\tnrows, ncols, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\tif unit == \"mm\":\n\t\t# Retrieve rainfall levels and create normalisation.\n\t\t# Retrieve colour map.\n\t\tcmap, levels = rainfall_cmap()\n\t\t# Create norm.\n\t\tnorm = colors.BoundaryNorm(levels, cmap.N)\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap, norm]\n\telif unit == \"mm/hr\":\n\t\t# Retrieve rainfall levels and create normalisation.\n\t\t# Retrieve colour map.\n\t\tcmap, levels = prate_1hr_cmap()\n\t\t# Create norm.\n\t\tnorm = colors.BoundaryNorm(levels, cmap.N)\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap, norm]\n\telse:\n\t\t# Define colour map for other parameters.\n\t\tif unit == \"K\":\n\t\t\t# Air temperature.\n\t\t\tcmap = \"RdYlBu_r\"\n\t\telif unit == \"hPa\":\n\t\t\t# Air pressure.\n\t\t\tcmap = \"rainbow\"\n\n\t\t\t# Cut the number of contourf levels.\n\t\t\tlevels = levels[::3]\n\t\telif unit == \"m s-1\":\n\t\t\tcmap = \"jet\"\n\t\telse:\n\t\t\t# Everything else.\n\t\t\tcmap = \"viridis\"\n\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap]\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\tcubes_row = []\n\t\tfor j in range(ncols):\n\t\t\t# Create longitude-latitude meshgrid.\n\t\t\tlon = cubes[i][j].coord('longitude').points\n\t\t\tlat = cubes[i][j].coord('latitude').points\n\t\t\tx, y = np.meshgrid(lon, lat)\n\n\t\t\t# Check if the grid is rectangular. \n\t\t\tif lon.ndim == 1:\n\t\t\t\t# Generate mesh grid.\n\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\telse:\n\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\tx, y = lon, lat\n\n\t\t\t# Get axis for plotting.\n\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\tax = axs\n\t\t\telif nrows == 1:\n\t\t\t\tax = axs[j]\n\t\t\telif ncols == 1:\n\t\t\t\tax = axs[i]\n\t\t\telse:\n\t\t\t\tax = axs[i][j]\n\n\t\t\t# Add high-resolution coastlines.\n\t\t\tax.coastlines(resolution='10m')\n\n\t\t\t# Add subplot title.\n\t\t\tax.set_title(subtitles[i][j])\n\n\t\t\t# Create filled contour plot.\n\t\t\tcontourf = ax.contourf(\n\t\t\t\tx, y, cubes[i][j].data, levels=cmapping[0], cmap=cmapping[1], extend=\"both\" \n\t\t\t)\n\n\t# Add title.\n\tfig.suptitle(\"{}\".format(title), weight='bold')\n\n\t# Create colour bar.\n\tcbar = plt.colorbar(\n\t\tcontourf, \n\t\tax=fig.axes, \n\t\taspect=60, \n\t\torientation=\"horizontal\", \n\t\textend=\"both\", \n\t\tfraction=0.02\n\t)\n\tcbar.set_label(unit)\n\tcbar.ax.tick_params(length=0)\n\n\t# Set size.\n\tfig.set_size_inches(size)\n\n\t# Save file.\n\tplt.savefig(fname)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.create_bias_plot","title":"create_bias_plot","text":"<pre><code>create_bias_plot(cubes, title, subtitles, levels, unit, fname, size)\n</code></pre> <p>Create a grid of spatial bias plots with statistical annotations.</p> <p>Each subplot corresponds to one Iris cube and is displayed on a Plate Carr\u00e9e map projection with coastlines and a title. A diverging colormap is used to highlight positive/negative biases, and summary statistics are added to each subplot.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of Iris cubes to plot. Each cube must contain latitude and longitude coordinates.</p> required <code>title</code> <code>str</code> <p>Overall title for the figure (added as a suptitle).</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>cubes</code>.</p> required <code>levels</code> <code>list of float</code> <p>Contour levels to use for filled contour plotting.</p> required <code>unit</code> <code>str</code> <p>Physical unit of the parameter (e.g., 'mm', 'K', 'hPa'). Determines the choice of colormap:</p> <ul> <li>\"mm\" \u2192 <code>BrBG</code> (precipitation biases)  </li> <li>everything else \u2192 <code>RdBu_r</code> (diverging red/blue)</li> </ul> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Notes <ul> <li>Bias values are expected in the input cubes (e.g., model minus observations).</li> <li>Each subplot includes anchored statistics (mean absolute error,   standard deviation, and mean bias) via   :func:<code>add_statistical_information</code>.</li> <li>A horizontal colorbar is added below the subplots, labelled with <code>unit</code>.</li> <li>Coastlines are drawn with 10m resolution.</li> <li>The function uses :func:<code>iris.plot.contourf</code> (<code>iplt.contourf</code>) for plotting,   which directly accepts an Iris cube.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_bias_plot(cubes, title, subtitles, levels, unit, fname, size):\n\t\"\"\"\n    Create a grid of spatial bias plots with statistical annotations.\n\n    Each subplot corresponds to one Iris cube and is displayed on a Plate\n    Carr\u00e9e map projection with coastlines and a title. A diverging colormap\n    is used to highlight positive/negative biases, and summary statistics\n    are added to each subplot.\n\n    Parameters\n    ----------\n    cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of Iris cubes to plot. Each cube must\n        contain latitude and longitude coordinates.\n    title : str\n        Overall title for the figure (added as a suptitle).\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `cubes`.\n    levels : list of float\n        Contour levels to use for filled contour plotting.\n    unit : str\n        Physical unit of the parameter (e.g., 'mm', 'K', 'hPa').\n        Determines the choice of colormap:\n\n        - \"mm\" \u2192 ``BrBG`` (precipitation biases)  \n        - everything else \u2192 ``RdBu_r`` (diverging red/blue)  \n    fname : str\n        Path (including filename) where the figure will be saved.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Notes\n    -----\n    - Bias values are expected in the input cubes (e.g., model minus observations).\n    - Each subplot includes anchored statistics (mean absolute error,\n      standard deviation, and mean bias) via\n      :func:`add_statistical_information`.\n    - A horizontal colorbar is added below the subplots, labelled with `unit`.\n    - Coastlines are drawn with 10m resolution.\n    - The function uses :func:`iris.plot.contourf` (`iplt.contourf`) for plotting,\n      which directly accepts an Iris cube.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\tncols = len(cubes[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(\n\t\tnrows, ncols, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\t# Set colour map.\n\tif unit == \"mm\":\n\t\t# Precipitation.\n\t\tcmap = \"BrBG\"\n\telse:\n\t\t# Everything else:\n\t\tcmap= \"RdBu_r\"\n\n\t# Loop through datasets.\n\tfor i in range(nrows):\n\t\tcubes_row = []\n\t\tfor j in range(ncols):\n\t\t\t# # Create longitude-latitude meshgrid.\n\t\t\t# lon = cubes[i][j].coord('longitude').points\n\t\t\t# lat = cubes[i][j].coord('latitude').points\n\t\t\t# x, y = np.meshgrid(lon, lat)\n\n\t\t\t# # Check if the grid is rectangular. \n\t\t\t# if lon.ndim == 1:\n\t\t\t# \t# Generate mesh grid.\n\t\t\t# \tx, y = np.meshgrid(lon, lat)\n\t\t\t# else:\n\t\t\t# \t# Get longitude-latitude as x-y.\n\t\t\t# \tx, y = lon, lat\n\n\t\t\t# Get axis for plotting.\n\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\tax = axs\n\t\t\telif nrows == 1:\n\t\t\t\tax = axs[j]\n\t\t\telif ncols == 1:\n\t\t\t\tax = axs[i]\n\t\t\telse:\n\t\t\t\tax = axs[i][j]\n\n\t\t\t# Add high-resolution coastlines.\n\t\t\tax.coastlines(resolution='10m')\n\n\t\t\t# Add subplot title.\n\t\t\tax.set_title(subtitles[i][j])\n\n\t\t\t# Create filled contour plot.\n\t\t\tcontourf = iplt.contourf(\n\t\t\t\tcubes[i][j], ax, levels=levels, cmap=cmap, extend=\"both\" \n\t\t\t)\n\n\t\t\t# Add statistical information.\n\t\t\tadd_statistical_information(cubes[i][j].data, unit, ax)\n\n\t# Add title.\n\tfig.suptitle(\"{}\".format(title), weight='bold')\n\n\t# Create colour bar.\n\tcbar = plt.colorbar(\n\t\tcontourf, \n\t\tax=fig.axes, \n\t\taspect=60, \n\t\torientation=\"horizontal\", \n\t\textend=\"both\", \n\t\tfraction=0.02\n\t)\n\tcbar.set_label(unit)\n\tcbar.ax.tick_params(length=0)\n\n\t# Set size.\n\tfig.set_size_inches(size)\n\n\t# Save file.\n\tplt.savefig(fname)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.create_param_ani","title":"create_param_ani","text":"<pre><code>create_param_ani(cubes, focus_period, title, subtitles, unit, folder, size, interval)\n</code></pre> <p>Create an animated sequence of meteorological parameter maps.</p> <p>Each subplot corresponds to one Iris cube, displayed on a Plate Carr\u00e9e map projection with coastlines. The function extracts data for a given focus period, creates filled contour maps for each timestep, and generates both individual frame images (PNG) and an MP4 animation.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of Iris cubes to animate. Each cube must contain dimensions including <code>time</code>, <code>latitude</code>, and <code>longitude</code>.</p> required <code>focus_period</code> <code>Constraint</code> <p>Constraint selecting the time range to animate.</p> required <code>title</code> <code>str</code> <p>Overall title for the animation. The current date is appended automatically in each frame.</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>cubes</code>.</p> required <code>unit</code> <code>str</code> <p>Unit of the parameter being plotted. Determines color mapping:</p> <ul> <li>\"mm\" \u2192 rainfall colormap via :func:<code>rainfall_cmap</code></li> <li>\"mm/hr\" \u2192 precipitation rate colormap via :func:<code>prate_1hr_cmap</code></li> <li>\"K\" \u2192 <code>RdYlBu_r</code></li> <li>\"hPa\" \u2192 <code>rainbow</code> (pressure, with optional contours)</li> <li>everything else \u2192 <code>viridis</code></li> </ul> required <code>folder</code> <code>str</code> <p>Path to the output folder. Individual frames (PNG) and the MP4 animation will be saved here. The folder is created if it does not exist.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <code>interval</code> <code>int</code> <p>Delay between frames in milliseconds (passed to :class:<code>matplotlib.animation.FuncAnimation</code>).</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the animation.</p> Notes <ul> <li>Each frame includes a title showing the simulation title and the   current datetime.</li> <li>If <code>\"Reference: ERA5\"</code> is in the title, only every fourth frame   is saved as PNG; otherwise, all frames are saved.</li> <li>Colorbars are added once at the bottom of the figure, labelled with <code>unit</code>.</li> <li>For pressure fields (<code>unit=\"hPa\"</code>), contour lines with labels are   added on top of the filled contours.</li> <li>Progress is tracked with a :class:<code>tqdm</code> progress bar.</li> <li>The final MP4 is saved as <code>&lt;folder&gt;/&lt;foldername&gt;_ani.mp4</code> where   <code>foldername</code> is the basename of <code>folder</code>.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_param_ani(cubes, focus_period, title, subtitles, unit, folder, size, interval):\n\t\"\"\"\n    Create an animated sequence of meteorological parameter maps.\n\n    Each subplot corresponds to one Iris cube, displayed on a Plate\n    Carr\u00e9e map projection with coastlines. The function extracts data for\n    a given focus period, creates filled contour maps for each timestep,\n    and generates both individual frame images (PNG) and an MP4 animation.\n\n    Parameters\n    ----------\n    cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of Iris cubes to animate. Each cube\n        must contain dimensions including ``time``, ``latitude``, and\n        ``longitude``.\n    focus_period : iris.Constraint\n        Constraint selecting the time range to animate.\n    title : str\n        Overall title for the animation. The current date is appended\n        automatically in each frame.\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `cubes`.\n    unit : str\n        Unit of the parameter being plotted. Determines color mapping:\n\n        - \"mm\" \u2192 rainfall colormap via :func:`rainfall_cmap`\n        - \"mm/hr\" \u2192 precipitation rate colormap via :func:`prate_1hr_cmap`\n        - \"K\" \u2192 ``RdYlBu_r``\n        - \"hPa\" \u2192 ``rainbow`` (pressure, with optional contours)\n        - everything else \u2192 ``viridis``\n    folder : str\n        Path to the output folder. Individual frames (PNG) and the MP4\n        animation will be saved here. The folder is created if it does\n        not exist.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n    interval : int\n        Delay between frames in milliseconds (passed to\n        :class:`matplotlib.animation.FuncAnimation`).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the animation.\n\n    Notes\n    -----\n    - Each frame includes a title showing the simulation title and the\n      current datetime.\n    - If ``\"Reference: ERA5\"`` is in the title, only every fourth frame\n      is saved as PNG; otherwise, all frames are saved.\n    - Colorbars are added once at the bottom of the figure, labelled with `unit`.\n    - For pressure fields (`unit=\"hPa\"`), contour lines with labels are\n      added on top of the filled contours.\n    - Progress is tracked with a :class:`tqdm` progress bar.\n    - The final MP4 is saved as ``&lt;folder&gt;/&lt;foldername&gt;_ani.mp4`` where\n      ``foldername`` is the basename of `folder`.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\tncols = len(cubes[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(\n\t\tnrows, ncols, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\tif unit == \"mm\":\n\t\t# Retrieve rainfall levels and create normalisation.\n\t\t# Retrieve colour map.\n\t\tcmap, levels = rainfall_cmap()\n\t\t# Create norm.\n\t\tnorm = colors.BoundaryNorm(levels, cmap.N)\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap, norm]\n\telif unit == \"mm/hr\":\n\t\t# Retrieve rainfall levels and create normalisation.\n\t\t# Retrieve colour map.\n\t\tcmap, levels = prate_1hr_cmap()\n\t\t# Create norm.\n\t\tnorm = colors.BoundaryNorm(levels, cmap.N)\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap, norm]\n\telse:\n\t\t# Define levels based on reference dataset.\n\t\t# Get maximum.\n\t\tmin_param = np.floor(\n\t\t\tcubes[0][0].collapsed(\n\t\t\t\t[\"time\", \"longitude\", \"latitude\"], iris.analysis.MIN\n\t\t\t).data\n\t\t)\n\t\t# Get minimum.\n\t\tmax_param = np.ceil(\n\t\t\tcubes[0][0].collapsed(\n\t\t\t\t[\"time\", \"longitude\", \"latitude\"], iris.analysis.MAX\n\t\t\t).data\n\t\t)\n\t\t# Convert to integers.\n\t\tmin_param, max_param = int(min_param), int(max_param)\n\t\t# Create levels.\n\t\tlevels = np.rint(\n\t\t\tnp.linspace(min_param, max_param, (max_param - min_param) + 1)\n\t\t)\n\n\t\t# Define colour map for other parameters.\n\t\tif unit == \"K\":\n\t\t\t# Air temperature.\n\t\t\tcmap = \"RdYlBu_r\"\n\t\telif unit == \"hPa\":\n\t\t\t# Air pressure.\n\t\t\tcmap = \"rainbow\"\n\n\t\t\t# Cut the number of contourf levels.\n\t\t\tlevels = levels[::3]\n\t\telse:\n\t\t\t# Everything else.\n\t\t\tcmap = \"viridis\"\n\n\t\t# Add to list.\n\t\tcmapping = [levels, cmap]\n\n\t# Loop through datasets.\n\tcontourfs = []\n\tnew_cubes = []\n\tfor i in range(nrows):\n\t\tcubes_row = []\n\t\tfor j in range(ncols):\n\t\t\t# Create longitude-latitude meshgrid.\n\t\t\tlon = cubes[i][j].coord('longitude').points\n\t\t\tlat = cubes[i][j].coord('latitude').points\n\t\t\tx, y = np.meshgrid(lon, lat)\n\n\t\t\t# Check if the grid is rectangular. \n\t\t\tif lon.ndim == 1:\n\t\t\t\t# Generate mesh grid.\n\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\telse:\n\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\tx, y = lon, lat\n\n\t\t\t# Get axis for plotting.\n\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\tax = axs\n\t\t\telif nrows == 1:\n\t\t\t\tax = axs[j]\n\t\t\telif ncols == 1:\n\t\t\t\tax = axs[i]\n\t\t\telse:\n\t\t\t\tax = axs[i][j]\n\n\t\t\t# Add high-resolution coastlines.\n\t\t\tax.coastlines(resolution='10m')\n\n\t\t\t# Add subplot title.\n\t\t\tax.set_title(subtitles[i][j])\n\n\t\t\t# Extract time period.\n\t\t\tcube = cubes[i][j].extract(focus_period)\n\t\t\tcubes_row.append(cube)\n\n\t\t\t# Create inital contour plot.\n\t\t\tif len(cmapping) == 3:\n\t\t\t\t# Rainfall.\n\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\tx, y, cube[0].data, \n\t\t\t\t\tlevels=cmapping[0], cmap=cmapping[1], norm=cmapping[2], \n\t\t\t\t\textend=\"max\"\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\t# Other parameters.\n\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\tx, y, cube[0].data, \n\t\t\t\t\tlevels=cmapping[0], cmap=cmapping[1] \n\t\t\t\t)\n\t\t\tcontourfs.append(contourf)\n\n\t\t# Add row of time constrained cubes.\n\t\tnew_cubes.append(cubes_row)\n\n\t# Redefine cubes variable.\n\tcubes = new_cubes\n\n\t# Update function for animation.\n\tdef update(frame, cubes, title, levels, pbar, folder, cmapping):\n\t\t# Determine number of rows.\n\t\tnrows = len(cubes)\n\t\tncols = len(cubes[0])\n\n\t\t# Remove plots.\n\t\t# Define global.\n\t\tglobal contours\n\t\tglobal contourfs\n\t\t# Try removal.\n\t\ttry:\n\t\t\tfor contourf in contourfs:\n\t\t\t\tcontourf.remove()\n\t\t\tfor contour in contours:\n\t\t\t\tcontour.remove()\n\t\texcept:\n\t\t\tpass\n\n\t\t# Determine date.\n\t\tcube_time = cubes[0][0].coord(\"time\")\n\t\tdate = cube_time.units.num2date(cube_time.points)[frame]\n\n\t\t# Loop through cubes.\n\t\tcontours = []\n\t\tcontourfs = []\n\t\tfor i in range(nrows):\n\t\t\tfor j in range(ncols):\n\t\t\t\t# Create longitude-latitude meshgrid.\n\t\t\t\tlon = cubes[i][j].coord('longitude').points\n\t\t\t\tlat = cubes[i][j].coord('latitude').points\n\n\t\t\t\t# Check if the grid is rectangular. \n\t\t\t\tif lon.ndim == 1:\n\t\t\t\t\t# Generate mesh grid.\n\t\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\t\telse:\n\t\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\t\tx, y = lon, lat\n\n\t\t\t\t# Get relevant cube.\n\t\t\t\tcube_data = cubes[i][j][frame].data\n\n\t\t\t\t# Get axis for plotting.\n\t\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\t\tax = axs\n\t\t\t\telif nrows == 1:\n\t\t\t\t\tax = axs[j]\n\t\t\t\telif ncols == 1:\n\t\t\t\t\tax = axs[i]\n\t\t\t\telse:\n\t\t\t\t\tax = axs[i][j]\n\n\t\t\t\t# Create inital contour plot.\n\t\t\t\tif len(cmapping) == 3:\n\t\t\t\t\t# Rainfall.\n\t\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\t\tx, y, cube_data, \n\t\t\t\t\t\tlevels=cmapping[0], cmap=cmapping[1], norm=cmapping[2], \n\t\t\t\t\t\textend=\"max\"\n\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\t# Every other parameter.\n\t\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\t\tx, y, cube_data, \n\t\t\t\t\t\tlevels=cmapping[0], cmap=cmapping[1], extend=\"both\"\n\t\t\t\t\t)\n\n\t\t\t\t\tif unit == \"hPa\":\n\t\t\t\t\t\t# Plot contour lines if looking at air pressure.\n\t\t\t\t\t\tcontour = ax.contour(\n\t\t\t\t\t\t\tx, y, cube_data, \n\t\t\t\t\t\t\tlevels=cmapping[0], linewidths=0.5, colors='k'\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\t# Add labels.\n\t\t\t\t\t\tax.clabel(contour, inline=True, fontsize=8)\n\n\t\t\t\t\t\t# Append to list.\n\t\t\t\t\t\tcontours.append(contour)\n\t\t\t\tcontourfs.append(contourf)\n\n\t\t# Add title.\n\t\tfig.suptitle(\n\t\t\t\"{}\\nDate: {}\".format(title, date.strftime('%d-%m-%Y %H:%M')), \n\t\t\tweight='bold'\n\t\t)\n\n\t\t# Save frame.\n\t\tfname = \"{}_{}.png\".format(\n\t\t\tfolder.rsplit('/', 1)[-1], date.strftime('%Y%m%d%H%M')\n\t\t)\n\n\t\tif not \"Reference: ERA5\" in title:\n\t\t\t# Save every frame is gridded dataset.\n\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\t\telse:\n\t\t\t# Save every fourth frame if ERA5.\n\t\t\tif frame % 4 == 0:\n\t\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\n\t\t# Update progress bar.\n\t\tpbar.update(1)\n\n\t\treturn contourfs\n\n\t# Initialize tqdm progress bar\n\tpbar = tqdm(\n\t\ttotal=cubes[i][j].shape[0], desc=\"Animating parameter plots\"\n\t)\n\n\t# Create animation.\n\tani = animation.FuncAnimation(\n\t\tfig, \n\t\tupdate, \n\t\tframes=cubes[i][j].shape[0], \n\t\tfargs=(cubes, title, levels, pbar, folder, cmapping),\n\t\tinterval=interval\n\t)\n\n\t# Create colour bar.\n\tcbar = plt.colorbar(\n\t\tcontourf, \n\t\tax=fig.axes, \n\t\taspect=60, \n\t\torientation=\"horizontal\", \n\t\textend=\"both\", \n\t\tfraction=0.02\n\t)\n\tcbar.set_label(unit)\n\tcbar.ax.tick_params(length=0)\n\n\t# Set size.\n\tfig.set_size_inches(size)\n\n\t# Check if folder exists.\n\tif not os.path.exists(folder):\n\t\tos.makedirs(folder)\n\n\t# Save file as MP4.\n\tfname = \"{}_ani.mp4\".format(folder.rsplit('/', 1)[-1])\n\tani.save(filename=\"{}/{}\".format(folder, fname))\n\n\t# Close progress bar.\n\tpbar.close()\n\n\treturn True\n</code></pre>"},{"location":"api/#master.create_bias_ani","title":"create_bias_ani","text":"<pre><code>create_bias_ani(cubes, focus_period, title, subtitles, levels, unit, folder, size, interval, stat_info=True)\n</code></pre> <p>Create an animated sequence of bias plots.</p> <p>Each subplot corresponds to one Iris cube, displayed on a Plate Carr\u00e9e map projection with coastlines. The function extracts data for a given focus period, creates filled contour maps for each timestep, and generates both individual frame images (PNG) and an MP4 animation. Optional summary statistics can be added to each subplot.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of Iris cubes to animate. Each cube must contain dimensions including <code>time</code>, <code>latitude</code>, and <code>longitude</code>. The data are expected to represent model\u2013observation differences (biases).</p> required <code>focus_period</code> <code>Constraint</code> <p>Constraint selecting the time range to animate.</p> required <code>title</code> <code>str</code> <p>Overall title for the animation. The current date is appended automatically in each frame.</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>cubes</code>.</p> required <code>levels</code> <code>list of float</code> <p>Contour levels for bias plotting.</p> required <code>unit</code> <code>str</code> <p>Unit of the variable (e.g., \"mm\", \"mm/hr\", \"K\"). Determines the colormap:</p> <ul> <li>\"mm\" or \"mm/hr\" \u2192 <code>BrBG</code> (precipitation biases)</li> <li>everything else \u2192 <code>RdBu_r</code> (diverging red/blue)</li> </ul> required <code>folder</code> <code>str</code> <p>Path to the output folder. Individual frames (PNG) and the MP4 animation will be saved here. The folder is created if it does not exist.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <code>interval</code> <code>int</code> <p>Delay between frames in milliseconds (passed to :class:<code>matplotlib.animation.FuncAnimation</code>).</p> required <code>stat_info</code> <code>bool</code> <p>If True (default), statistical summaries (mean absolute value, standard deviation, mean bias) are added to each subplot using :func:<code>add_statistical_information</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the animation.</p> Notes <ul> <li>Each frame includes a title showing the simulation title and the   current datetime.</li> <li>If <code>\"Reference: ERA5\"</code> is in the title, only every fourth frame   is saved as PNG; otherwise, all frames are saved.</li> <li>A horizontal colorbar is added below the subplots, labelled with <code>unit</code>.</li> <li>Coastlines are drawn with 10m resolution.</li> <li>Progress is tracked with a :class:<code>tqdm</code> progress bar.</li> <li>The final MP4 is saved as <code>&lt;folder&gt;/&lt;foldername&gt;_ani.mp4</code> where   <code>foldername</code> is the basename of <code>folder</code>.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_bias_ani(cubes, focus_period, title, subtitles, levels, unit, folder, size, interval, stat_info=True):\n\t\"\"\"\n    Create an animated sequence of bias plots.\n\n    Each subplot corresponds to one Iris cube, displayed on a Plate\n    Carr\u00e9e map projection with coastlines. The function extracts data\n    for a given focus period, creates filled contour maps for each timestep,\n    and generates both individual frame images (PNG) and an MP4 animation.\n    Optional summary statistics can be added to each subplot.\n\n    Parameters\n    ----------\n    cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of Iris cubes to animate. Each cube must\n        contain dimensions including ``time``, ``latitude``, and ``longitude``.\n        The data are expected to represent model\u2013observation differences\n        (biases).\n    focus_period : iris.Constraint\n        Constraint selecting the time range to animate.\n    title : str\n        Overall title for the animation. The current date is appended\n        automatically in each frame.\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `cubes`.\n    levels : list of float\n        Contour levels for bias plotting.\n    unit : str\n        Unit of the variable (e.g., \"mm\", \"mm/hr\", \"K\"). Determines\n        the colormap:\n\n        - \"mm\" or \"mm/hr\" \u2192 ``BrBG`` (precipitation biases)\n        - everything else \u2192 ``RdBu_r`` (diverging red/blue)\n    folder : str\n        Path to the output folder. Individual frames (PNG) and the MP4\n        animation will be saved here. The folder is created if it does\n        not exist.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n    interval : int\n        Delay between frames in milliseconds (passed to\n        :class:`matplotlib.animation.FuncAnimation`).\n    stat_info : bool, optional\n        If True (default), statistical summaries (mean absolute value,\n        standard deviation, mean bias) are added to each subplot using\n        :func:`add_statistical_information`.\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the animation.\n\n    Notes\n    -----\n    - Each frame includes a title showing the simulation title and the\n      current datetime.\n    - If ``\"Reference: ERA5\"`` is in the title, only every fourth frame\n      is saved as PNG; otherwise, all frames are saved.\n    - A horizontal colorbar is added below the subplots, labelled with `unit`.\n    - Coastlines are drawn with 10m resolution.\n    - Progress is tracked with a :class:`tqdm` progress bar.\n    - The final MP4 is saved as ``&lt;folder&gt;/&lt;foldername&gt;_ani.mp4`` where\n      ``foldername`` is the basename of `folder`.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(cubes)\n\tncols = len(cubes[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(\n\t\tnrows, ncols, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\t# Set colour map.\n\tif unit == \"mm\" or unit == \"mm/hr\":\n\t\t# Precipitation.\n\t\tcmap = \"BrBG\"\n\telse:\n\t\t# Everything else:\n\t\tcmap= \"RdBu_r\"\n\n\t# Loop through datasets.\n\tcontourfs = []\n\tnew_cubes = []\n\tfor i in range(nrows):\n\t\tcubes_row = []\n\t\tfor j in range(ncols):\n\t\t\t# Create longitude-latitude meshgrid.\n\t\t\tlon = cubes[i][j].coord('longitude').points\n\t\t\tlat = cubes[i][j].coord('latitude').points\n\t\t\tx, y = np.meshgrid(lon, lat)\n\n\t\t\t# Check if the grid is rectangular. \n\t\t\tif lon.ndim == 1:\n\t\t\t\t# Generate mesh grid.\n\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\telse:\n\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\tx, y = lon, lat\n\n\t\t\t# Get axis for plotting.\n\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\tax = axs\n\t\t\telif nrows == 1:\n\t\t\t\tax = axs[j]\n\t\t\telif ncols == 1:\n\t\t\t\tax = axs[i]\n\t\t\telse:\n\t\t\t\tax = axs[i][j]\n\n\t\t\t# Add high-resolution coastlines.\n\t\t\tax.coastlines(resolution='10m')\n\n\t\t\t# Add subplot title.\n\t\t\tax.set_title(subtitles[i][j])\n\n\t\t\t# Extract time period.\n\t\t\tcube = cubes[i][j].extract(focus_period)\n\t\t\tcubes_row.append(cube)\n\n\t\t\t# Create inital contour plot.\n\t\t\tcontourf = ax.contourf(\n\t\t\t\tx, y, cube[0].data, levels=levels, cmap=cmap, extend=\"both\"\n\t\t\t)\n\t\t\tcontourfs.append(contourf)\n\n\t\t\t# Add statistical information.\n\t\t\tif stat_info:\n\t\t\t\tadd_statistical_information(cubes[i][j].data, unit, ax)\n\n\t\t# Add row of time constrained cubes.\n\t\tnew_cubes.append(cubes_row)\n\n\t# Redefine cubes variable.\n\tcubes = new_cubes\n\n\t# Update function for animation.\n\tdef update(frame, cubes, title, levels, pbar, folder):\n\t\t# Determine number of rows.\n\t\tnrows = len(cubes)\n\t\tncols = len(cubes[0])\n\n\t\t# Remove plots.\n\t\t# Define global.\n\t\tglobal contourfs\n\t\t# Try removal.\n\t\ttry:\n\t\t\tfor contourf in contourfs:\n\t\t\t\tcontourf.remove()\n\t\texcept:\n\t\t\tpass\n\n\t\t# Determine date.\n\t\tcube_time = cubes[0][0].coord(\"time\")\n\t\tdate = cube_time.units.num2date(cube_time.points)[frame]\n\n\t\t# Set colour map.\n\t\tif unit == \"mm\":\n\t\t\t# Precipitation.\n\t\t\tcmap = \"BrBG\"\n\t\telse:\n\t\t\t# Everything else:\n\t\t\tcmap= \"RdBu_r\"\n\n\t\t# Loop through cubes.\n\t\tcontourfs = []\n\t\tfor i in range(nrows):\n\t\t\tfor j in range(ncols):\n\t\t\t\t# Create longitude-latitude meshgrid.\n\t\t\t\tlon = cubes[i][j].coord('longitude').points\n\t\t\t\tlat = cubes[i][j].coord('latitude').points\n\t\t\t\tx, y = np.meshgrid(lon, lat)\n\n\t\t\t\t# Check if the grid is rectangular. \n\t\t\t\tif lon.ndim == 1:\n\t\t\t\t\t# Generate mesh grid.\n\t\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\t\telse:\n\t\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\t\tx, y = lon, lat\n\n\t\t\t\t# Get axis for plotting.\n\t\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\t\tax = axs\n\t\t\t\telif nrows == 1:\n\t\t\t\t\tax = axs[j]\n\t\t\t\telif ncols == 1:\n\t\t\t\t\tax = axs[i]\n\t\t\t\telse:\n\t\t\t\t\tax = axs[i][j]\n\n\t\t\t\t# Create inital contour plot.\n\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\tx, y, cubes[i][j][frame].data, levels=levels, cmap=cmap, extend=\"both\"\n\t\t\t\t)\n\t\t\t\tcontourfs.append(contourf)\n\n\t\t# Add title.\n\t\tfig.suptitle(\n\t\t\t\"{}\\nDate: {}\".format(title, date.strftime('%d-%m-%Y %H:%M')), \n\t\t\tweight='bold'\n\t\t)\n\n\t\t# Save frame.\n\t\tfname = \"{}_{}.png\".format(\n\t\t\tfolder.rsplit('/', 1)[-1], date.strftime('%Y%m%d%H%M')\n\t\t)\n\n\t\tif not \"Reference: ERA5\" in title:\n\t\t\t# Save every frame is gridded dataset.\n\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\t\telse:\n\t\t\t# Save every fourth frame if ERA5.\n\t\t\tif frame % 4 == 0:\n\t\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\n\t\t# Update progress bar.\n\t\tpbar.update(1)\n\n\t\treturn contourfs\n\n\t# Set size.\n\tfig.set_size_inches(size)\n\n\t# Initialize tqdm progress bar\n\tpbar = tqdm(\n\t\ttotal=cubes[i][j].shape[0], desc=\"Animating bias plots\"\n\t)\n\n\t# Create animation.\n\tani = animation.FuncAnimation(\n\t\tfig, \n\t\tupdate, \n\t\tframes=cubes[i][j].shape[0], \n\t\tfargs=(cubes, title, levels, pbar, folder),\n\t\tinterval=interval\n\t)\n\n\t# Create colour bar.\n\tcbar = plt.colorbar(\n\t\tcontourf, \n\t\tax=fig.axes, \n\t\taspect=60, \n\t\torientation=\"horizontal\", \n\t\textend=\"both\", \n\t\tfraction=0.02\n\t)\n\tcbar.set_label(unit)\n\tcbar.ax.tick_params(length=0)\n\n\t# Check if folder exists.\n\tif not os.path.exists(folder):\n\t\tos.makedirs(folder)\n\n\t# Save file as MP4.\n\tfname = \"{}_ani.mp4\".format(folder.rsplit('/', 1)[-1])\n\tani.save(filename=\"{}/{}\".format(folder, fname))\n\n\t# Close progress bar.\n\tpbar.close()\n\n\treturn True\n</code></pre>"},{"location":"api/#master.calculate_crude_track","title":"calculate_crude_track","text":"<pre><code>calculate_crude_track(psl_cube, time_constraint=None)\n</code></pre> <p>Estimate a crude extratropical cyclone track from sea-level pressure data.</p> <p>For each timestep in the input cube, the location of the minimum sea-level pressure is identified. The resulting sequence of longitude/latitude points provides an approximate storm track.</p> <p>Parameters:</p> Name Type Description Default <code>psl_cube</code> <code>Cube</code> <p>Sea-level pressure cube with dimensions <code>(time, latitude, longitude)</code>. Must include <code>time</code>, <code>latitude</code>, and <code>longitude</code> coordinates.</p> required <code>time_constraint</code> <code>Constraint</code> <p>Constraint to restrict the analysis to a subset of the time dimension. Default is None (use all available timesteps).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>lon</code> <code>ndarray</code> <p>1D array of longitudes (degrees east) at the minimum pressure location for each timestep.</p> <code>lat</code> <code>ndarray</code> <p>1D array of latitudes (degrees north) at the minimum pressure location for each timestep.</p> Notes <ul> <li>The track is \u201ccrude\u201d because only the single grid point of minimum sea-level   pressure is retained per timestep; no temporal smoothing or tracking   heuristics are applied.</li> <li>Uses :func:<code>iris.analysis.MIN</code> to collapse over latitude and longitude.</li> <li>If multiple points share the same minimum value at a timestep, all are returned,   which may result in more points than timesteps.</li> </ul> Source code in <code>master.py</code> <pre><code>def calculate_crude_track(psl_cube, time_constraint=None):\n\t\"\"\"\n    Estimate a crude extratropical cyclone track from sea-level pressure data.\n\n    For each timestep in the input cube, the location of the minimum sea-level\n    pressure is identified. The resulting sequence of longitude/latitude\n    points provides an approximate storm track.\n\n    Parameters\n    ----------\n    psl_cube : iris.cube.Cube\n        Sea-level pressure cube with dimensions ``(time, latitude, longitude)``.\n        Must include ``time``, ``latitude``, and ``longitude`` coordinates.\n    time_constraint : iris.Constraint, optional\n        Constraint to restrict the analysis to a subset of the time dimension.\n        Default is None (use all available timesteps).\n\n    Returns\n    -------\n    lon : numpy.ndarray\n        1D array of longitudes (degrees east) at the minimum pressure location\n        for each timestep.\n    lat : numpy.ndarray\n        1D array of latitudes (degrees north) at the minimum pressure location\n        for each timestep.\n\n    Notes\n    -----\n    - The track is \u201ccrude\u201d because only the single grid point of minimum sea-level\n      pressure is retained per timestep; no temporal smoothing or tracking\n      heuristics are applied.\n    - Uses :func:`iris.analysis.MIN` to collapse over latitude and longitude.\n    - If multiple points share the same minimum value at a timestep, all are returned,\n      which may result in more points than timesteps.\n    \"\"\"\n\t# Extract relevant period.\n\tif time_constraint != None:\n\t\tpsl_cube = psl_cube.extract(time_constraint)\n\n\t# Calculate minimum pressure values.\n\tmin_psl = psl_cube.collapsed(\n\t\t[\"longitude\", \"latitude\"], iris.analysis.MIN\n\t).data + np.zeros(\n\t\t(psl_cube.shape[1], psl_cube.shape[2], psl_cube.shape[0])\n\t)\n\tmin_psl = np.transpose(min_psl, (2, 0, 1))\n\t# Get indices.\n\tmin_psl_indx = np.where(psl_cube.data == min_psl)\n\n\t# Get relevant points.\n\tlon = psl_cube[min_psl_indx].coord(\"longitude\").points\n\tlat = psl_cube[min_psl_indx].coord(\"latitude\").points\n\n\treturn lon, lat\n</code></pre>"},{"location":"api/#master.plot_extratropical_cyclone_track","title":"plot_extratropical_cyclone_track","text":"<pre><code>plot_extratropical_cyclone_track(cubes, focus_t0, focus_t1, title, labels, fname)\n</code></pre> <p>Plot extratropical cyclone tracks from one or more simulations.</p> <p>Each input cube is constrained to a focus period, a crude track (longitude/latitude sequence) is calculated, and the resulting tracks are plotted on a Plate Carr\u00e9e map with coastlines and land shading. Multiple simulations can be shown together with distinct colors.</p> <p>Parameters:</p> Name Type Description Default <code>cubes</code> <code>list of iris.cube.Cube</code> <p>List of pressure (e.g., sea-level pressure) cubes from different simulations. Each cube must contain time, latitude, and longitude coordinates.</p> required <code>focus_t0</code> <code>datetime - like</code> <p>Start of the focus period (inclusive).</p> required <code>focus_t1</code> <code>datetime - like</code> <p>End of the focus period (inclusive).</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> required <code>labels</code> <code>list of str</code> <p>Labels for each cyclone track, one per input cube.</p> required <code>fname</code> <code>str</code> <p>Path (including filename) where the figure will be saved.</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the plot.</p> Notes <ul> <li>Tracks are derived using :func:<code>calculate_crude_track</code>, which should   return longitude and latitude arrays describing the storm path.</li> <li>Only the period between <code>focus_t0</code> and <code>focus_t1</code> is plotted.</li> <li>Land is shaded in beige (<code>#FFE6B3</code>), with coastlines drawn at 10m   resolution.</li> <li>Colors cycle through a standard list   (<code>['b', 'orange', 'g', 'r', 'purple', 'c']</code>).</li> <li>The output figure size is fixed to <code>(7.5, 4)</code> inches.</li> </ul> Source code in <code>master.py</code> <pre><code>def plot_extratropical_cyclone_track(cubes, focus_t0, focus_t1, title, labels, fname):\n\t\"\"\"\n    Plot extratropical cyclone tracks from one or more simulations.\n\n    Each input cube is constrained to a focus period, a crude track\n    (longitude/latitude sequence) is calculated, and the resulting tracks\n    are plotted on a Plate Carr\u00e9e map with coastlines and land shading.\n    Multiple simulations can be shown together with distinct colors.\n\n    Parameters\n    ----------\n    cubes : list of iris.cube.Cube\n        List of pressure (e.g., sea-level pressure) cubes from different\n        simulations. Each cube must contain time, latitude, and longitude\n        coordinates.\n    focus_t0 : datetime-like\n        Start of the focus period (inclusive).\n    focus_t1 : datetime-like\n        End of the focus period (inclusive).\n    title : str\n        Title for the plot.\n    labels : list of str\n        Labels for each cyclone track, one per input cube.\n    fname : str\n        Path (including filename) where the figure will be saved.\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the plot.\n\n    Notes\n    -----\n    - Tracks are derived using :func:`calculate_crude_track`, which should\n      return longitude and latitude arrays describing the storm path.\n    - Only the period between `focus_t0` and `focus_t1` is plotted.\n    - Land is shaded in beige (``#FFE6B3``), with coastlines drawn at 10m\n      resolution.\n    - Colors cycle through a standard list\n      (``['b', 'orange', 'g', 'r', 'purple', 'c']``).\n    - The output figure size is fixed to ``(7.5, 4)`` inches.\n    \"\"\"\n\t# Create plot space.\n\tfig, ax = plt.subplots(\n\t\t1, 1, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\t# Add high-resolution coastlines.\n\tax.coastlines(resolution='10m')\n\n\t# Fill land and ocean.\n\tax.add_feature(cfeature.LAND, facecolor='#FFE6B3')\n\n\t# List of standard colors in Matplotlib\n\tcolors = ['b', 'orange', 'g', 'r', 'purple', 'c']\n\n\t# Focus period.\n\tfocus_period = iris.Constraint(\n\t\ttime=lambda cell: focus_t0 &lt;= cell.point &lt;= focus_t1\n\t)\n\n\t# Loop through simulation tracks.\n\tfor it in range(len(cubes)):\n\t\t# Calculate storm longitude and latitude.\n\t\tcube = cubes[it].extract(focus_period)\n\t\tstorm_eowyn_lon, storm_eowyn_lat = calculate_crude_track(psl_cube=cube)\n\n\t\t# Plot result.\n\t\tax.plot(storm_eowyn_lon, storm_eowyn_lat, label=labels[it], color=colors[it])\n\n\t# Add legend.\n\tplt.legend(loc=0, fontsize=6)\n\n\t# Add title.\n\tfig.suptitle(title, weight='bold')\n\n\t# Set size.\n\tfig.set_size_inches(7.5, 4)\n\n\t# Save.\n\tplt.savefig(fname)\n\n\treturn True\n</code></pre>"},{"location":"api/#master.create_weather_map_ani","title":"create_weather_map_ani","text":"<pre><code>create_weather_map_ani(pres_cubes, pr_cubes, focus_period, title, subtitles, unit, folder, size, interval)\n</code></pre> <p>Create an animated weather map showing precipitation rate and mean sea-level pressure.</p> <p>For each timestep in the focus period, precipitation rate (shaded contours) is overlaid with mean sea-level pressure (black contour lines). The function generates both individual frame images (PNG) and an MP4 animation.</p> <p>Parameters:</p> Name Type Description Default <code>pres_cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of sea-level pressure cubes. Each cube must include dimensions <code>(time, latitude, longitude)</code> and a <code>time</code> coordinate.</p> required <code>pr_cubes</code> <code>list of list of iris.cube.Cube</code> <p>Nested list (2D structure) of precipitation rate cubes, same shape as <code>pres_cubes</code>.</p> required <code>focus_period</code> <code>Constraint</code> <p>Constraint selecting the time period to animate.</p> required <code>title</code> <code>str</code> <p>Overall title for the animation. The current date is appended automatically in each frame.</p> required <code>subtitles</code> <code>list of list of str</code> <p>Nested list of subplot titles, same shape as <code>pres_cubes</code> / <code>pr_cubes</code>.</p> required <code>unit</code> <code>str</code> <p>Unit string for the precipitation rate (e.g., <code>\"mm/hr\"</code>). Used to label the colorbar.</p> required <code>folder</code> <code>str</code> <p>Path to the output folder. Individual frames (PNG) and the MP4 animation will be saved here. The folder is created if it does not exist.</p> required <code>size</code> <code>tuple of float</code> <p>Figure size in inches, e.g., (width, height).</p> required <code>interval</code> <code>int</code> <p>Delay between frames in milliseconds (passed to :class:<code>matplotlib.animation.FuncAnimation</code>).</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> <p>Returns <code>True</code> after successfully creating and saving the animation.</p> Notes <ul> <li>Precipitation shading uses :func:<code>prate_1hr_cmap</code> for contour levels and colormap.</li> <li>Sea-level pressure contours are drawn every 5 hPa from 930 to 1040 hPa,   with inline labels.</li> <li>If <code>\"Reference: ERA5\"</code> is present in the title, only every fourth frame   is saved as PNG; otherwise, all frames are saved.</li> <li>A horizontal colorbar is added below the subplots, labelled with <code>unit</code>.</li> <li>Coastlines are drawn with 10m resolution.</li> <li>Progress is tracked with a :class:<code>tqdm</code> progress bar.</li> <li>The final MP4 is saved as <code>&lt;folder&gt;/&lt;foldername&gt;_ani.mp4</code> where   <code>foldername</code> is the basename of <code>folder</code>.</li> </ul> Source code in <code>master.py</code> <pre><code>def create_weather_map_ani(pres_cubes, pr_cubes, focus_period, title, subtitles, unit, folder, size, interval):\n\t\"\"\"\n    Create an animated weather map showing precipitation rate and mean sea-level pressure.\n\n    For each timestep in the focus period, precipitation rate (shaded contours)\n    is overlaid with mean sea-level pressure (black contour lines). The function\n    generates both individual frame images (PNG) and an MP4 animation.\n\n    Parameters\n    ----------\n    pres_cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of sea-level pressure cubes. Each cube must\n        include dimensions ``(time, latitude, longitude)`` and a ``time`` coordinate.\n    pr_cubes : list of list of iris.cube.Cube\n        Nested list (2D structure) of precipitation rate cubes, same shape as\n        `pres_cubes`.\n    focus_period : iris.Constraint\n        Constraint selecting the time period to animate.\n    title : str\n        Overall title for the animation. The current date is appended automatically\n        in each frame.\n    subtitles : list of list of str\n        Nested list of subplot titles, same shape as `pres_cubes` / `pr_cubes`.\n    unit : str\n        Unit string for the precipitation rate (e.g., ``\"mm/hr\"``). Used to\n        label the colorbar.\n    folder : str\n        Path to the output folder. Individual frames (PNG) and the MP4 animation\n        will be saved here. The folder is created if it does not exist.\n    size : tuple of float\n        Figure size in inches, e.g., (width, height).\n    interval : int\n        Delay between frames in milliseconds (passed to\n        :class:`matplotlib.animation.FuncAnimation`).\n\n    Returns\n    -------\n    success : bool\n        Returns ``True`` after successfully creating and saving the animation.\n\n    Notes\n    -----\n    - Precipitation shading uses :func:`prate_1hr_cmap` for contour levels and colormap.\n    - Sea-level pressure contours are drawn every 5 hPa from 930 to 1040 hPa,\n      with inline labels.\n    - If ``\"Reference: ERA5\"`` is present in the title, only every fourth frame\n      is saved as PNG; otherwise, all frames are saved.\n    - A horizontal colorbar is added below the subplots, labelled with `unit`.\n    - Coastlines are drawn with 10m resolution.\n    - Progress is tracked with a :class:`tqdm` progress bar.\n    - The final MP4 is saved as ``&lt;folder&gt;/&lt;foldername&gt;_ani.mp4`` where\n      ``foldername`` is the basename of `folder`.\n    \"\"\"\n\t# Determine number of rows.\n\tnrows = len(pres_cubes)\n\tncols = len(pres_cubes[0])\n\n\t# Create plot space.\n\tfig, axs = plt.subplots(\n\t\tnrows, ncols, dpi=300, subplot_kw={'projection': ccrs.PlateCarree()}\n\t)\n\n\t# Retrieve rainfall levels and create normalisation.\n\t# Retrieve colour map.\n\tcmap, levels = prate_1hr_cmap()\n\t# Create norm.\n\tnorm = colors.BoundaryNorm(levels, cmap.N)\n\t# Add to list.\n\tcmapping = [levels, cmap, norm]\n\n\t# Loop through datasets.\n\tcontourfs = []\n\tnew_pres_cubes = []\n\tnew_pr_cubes = []\n\tfor i in range(nrows):\n\t\tpres_cubes_row = []\n\t\tpr_cubes_row = []\n\t\tfor j in range(ncols):\n\t\t\t# Create longitude-latitude meshgrid.\n\t\t\tlon = pr_cubes[i][j].coord('longitude').points\n\t\t\tlat = pr_cubes[i][j].coord('latitude').points\n\t\t\tx, y = np.meshgrid(lon, lat)\n\n\t\t\t# Check if the grid is rectangular. \n\t\t\tif lon.ndim == 1:\n\t\t\t\t# Generate mesh grid.\n\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\telse:\n\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\tx, y = lon, lat\n\n\t\t\t# Get axis for plotting.\n\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\tax = axs\n\t\t\telif nrows == 1:\n\t\t\t\tax = axs[j]\n\t\t\telif ncols == 1:\n\t\t\t\tax = axs[i]\n\t\t\telse:\n\t\t\t\tax = axs[i][j]\n\n\t\t\t# Add high-resolution coastlines.\n\t\t\tax.coastlines(resolution='10m')\n\n\t\t\t# Add subplot title.\n\t\t\tax.set_title(subtitles[i][j])\n\n\t\t\t# Extract time period.\n\t\t\t# Pressure.\n\t\t\tpres_cube = pres_cubes[i][j].extract(focus_period)\n\t\t\tpres_cubes_row.append(pres_cube)\n\t\t\t# Rainfall.\n\t\t\tpr_cube = pr_cubes[i][j].extract(focus_period)\n\t\t\tpr_cubes_row.append(pr_cube)\n\n\t\t\t# Precipitation rate.\n\t\t\tcontourf = ax.contourf(\n\t\t\t\tx, y, pr_cube[0].data, \n\t\t\t\tlevels=cmapping[0], cmap=cmapping[1], norm=cmapping[2], \n\t\t\t\textend=\"max\"\n\t\t\t)\n\t\t\tcontourfs.append(contourf)\n\n\t\t# Add row of time constrained cubes.\n\t\tnew_pres_cubes.append(pres_cubes_row)\n\t\tnew_pr_cubes.append(pr_cubes_row)\n\n\t# Redefine cubes variable.\n\tpres_cubes = new_pres_cubes\n\tpr_cubes = new_pr_cubes\n\n\t# Update function for animation.\n\tdef update(frame, pres_cubes, pr_cubes, title, levels, pbar, folder, cmapping):\n\t\t# Determine number of rows.\n\t\tnrows = len(pr_cubes)\n\t\tncols = len(pr_cubes[0])\n\n\t\t# Remove plots.\n\t\t# Define global.\n\t\tglobal contours\n\t\tglobal contourfs\n\t\t# Try removal.\n\t\ttry:\n\t\t\tfor contourf in contourfs:\n\t\t\t\tcontourf.remove()\n\t\t\tfor contour in contours:\n\t\t\t\tcontour.remove()\n\t\texcept:\n\t\t\tpass\n\n\t\t# Determine date.\n\t\tcube_time = pr_cubes[0][0].coord(\"time\")\n\t\tdate = cube_time.units.num2date(cube_time.points)[frame]\n\n\t\t# Loop through cubes.\n\t\tcontours = []\n\t\tcontourfs = []\n\t\tfor i in range(nrows):\n\t\t\tfor j in range(ncols):\n\t\t\t\t# Create longitude-latitude meshgrid.\n\t\t\t\tlon = pr_cubes[i][j].coord('longitude').points\n\t\t\t\tlat = pr_cubes[i][j].coord('latitude').points\n\n\t\t\t\t# Check if the grid is rectangular. \n\t\t\t\tif lon.ndim == 1:\n\t\t\t\t\t# Generate mesh grid.\n\t\t\t\t\tx, y = np.meshgrid(lon, lat)\n\t\t\t\telse:\n\t\t\t\t\t# Get longitude-latitude as x-y.\n\t\t\t\t\tx, y = lon, lat\n\n\t\t\t\t# Get relevant cube.\n\t\t\t\tpres_cube_data = pres_cubes[i][j][frame].data\n\t\t\t\tpr_cube_data = pr_cubes[i][j][frame].data\n\n\t\t\t\t# Get axis for plotting.\n\t\t\t\tif nrows == 1 and ncols == 1:\n\t\t\t\t\tax = axs\n\t\t\t\telif nrows == 1:\n\t\t\t\t\tax = axs[j]\n\t\t\t\telif ncols == 1:\n\t\t\t\t\tax = axs[i]\n\t\t\t\telse:\n\t\t\t\t\tax = axs[i][j]\n\n\t\t\t\t# Precipitation rate.\n\t\t\t\tcontourf = ax.contourf(\n\t\t\t\t\tx, y, pr_cube_data, \n\t\t\t\t\tlevels=cmapping[0], cmap=cmapping[1], norm=cmapping[2], \n\t\t\t\t\textend=\"max\"\n\t\t\t\t)\n\n\t\t\t\t# Mean sea level pressure.\n\t\t\t\tpres_levels = np.arange(930, 1040 + 5, 5)\n\t\t\t\tcontour = ax.contour(\n\t\t\t\t\tx, y, pres_cube_data, levels=pres_levels, linewidths=0.5, colors='k'\n\t\t\t\t)\n\n\t\t\t\t# Add labels.\n\t\t\t\tax.clabel(contour, inline=True, fontsize=8)\n\n\t\t\t\t# Append to list.\n\t\t\t\tcontours.append(contour)\n\n\t\t\t\t# Append contourf.\t\n\t\t\t\tcontourfs.append(contourf)\n\n\t\t# Add title.\n\t\tfig.suptitle(\n\t\t\t\"{}\\nDate: {}\".format(title, date.strftime('%d-%m-%Y %H:%M')), \n\t\t\tweight='bold'\n\t\t)\n\n\t\t# Save frame.\n\t\tfname = \"{}_{}.png\".format(\n\t\t\tfolder.rsplit('/', 1)[-1], date.strftime('%Y%m%d%H%M')\n\t\t)\n\n\t\tif not \"Reference: ERA5\" in title:\n\t\t\t# Save every frame is gridded dataset.\n\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\t\telse:\n\t\t\t# Save every fourth frame if ERA5.\n\t\t\tif frame % 4 == 0:\n\t\t\t\tplt.savefig(\"{}/{}\".format(folder, fname))\n\n\t\t# Update progress bar.\n\t\tpbar.update(1)\n\n\t\treturn contourfs\n\n\t# Initialize tqdm progress bar\n\tpbar = tqdm(\n\t\ttotal=pr_cubes[i][j].shape[0], desc=\"Animating parameter plots\"\n\t)\n\n\t# Create animation.\n\tani = animation.FuncAnimation(\n\t\tfig, \n\t\tupdate, \n\t\tframes=pr_cubes[i][j].shape[0], \n\t\tfargs=(pres_cubes, pr_cubes, title, levels, pbar, folder, cmapping),\n\t\tinterval=interval\n\t)\n\n\t# Create colour bar.\n\tcbar = plt.colorbar(\n\t\tcontourf, \n\t\tax=fig.axes, \n\t\taspect=60, \n\t\torientation=\"horizontal\", \n\t\textend=\"both\", \n\t\tfraction=0.02\n\t)\n\tcbar.set_label(unit)\n\tcbar.ax.tick_params(length=0)\n\n\t# Set size.\n\tfig.set_size_inches(size)\n\n\t# Check if folder exists.\n\tif not os.path.exists(folder):\n\t\tos.makedirs(folder)\n\n\t# Save file as MP4.\n\tfname = \"{}_ani.mp4\".format(folder.rsplit('/', 1)[-1])\n\tani.save(filename=\"{}/{}\".format(folder, fname))\n\n\t# Close progress bar.\n\tpbar.close()\n\n\treturn True\n</code></pre>"}]}